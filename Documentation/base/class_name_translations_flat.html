<HTML><HEAD>
<meta name="description" content="Translations of class names between a storing and a retrieving system. Values in this table are names of classes in the retrieving system, indexed by names of generating classes in the storing system (i.e. with no generic arguments). Values may have generic arguments (e.g. MY_CLASS [DOUBLE]), thus allowing a very simple conversion of a non-generic class into a generic class. The presence of entries in this table affects all retrieve operations for objects stored using `independent_store'."/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="legal" content="See notice at end of class."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2012, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>class_name_translations Flat</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="class_name_translations_chart.html">Chart</A></TD><TD><A HREF="class_name_translations_links.html">Relations</A></TD><TD><A HREF="class_name_translations.html">Text</A></TD><TD>Flat</TD><TD><A HREF="class_name_translations_short.html">Contracts</A></TD><TD><A HREF="class_name_translations_flatshort.html">Flat contracts</A></TD></TR></TABLE><B>note</B>
    description: "[
        Translations of class names between a storing and a retrieving
        system. Values in this table are names of classes in the retrieving
        system, indexed by names of generating classes in the storing
        system (i.e. with no generic arguments). Values may have generic
        arguments (e.g. "MY_CLASS [DOUBLE]"), thus allowing a very simple
        conversion of a non-generic class into a generic class. The
        presence of entries in this table affects all retrieve operations
        for objects stored using `independent_store'.
    ]"
    library: "Free implementation of ELKS library"
    status: "See notice at end of class."
    legal: "See notice at end of class."
    date: "$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $"
    revision: "$Revision: 91981 $"

<B>class</B> 
    <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>

<B>create</B> 
    <A HREF="../elks/class_name_translations_flat.html#f_default_create">default_create</A>


<B>create</B> {<A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>}
    <A HREF="../elks/hash_table_flat.html#f_make">make</A>

<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_accommodate"><A HREF="../elks/hash_table_flat.html#f_accommodate">accommodate</A> (n: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reallocate table with enough space for </FONT>`n'<FONT COLOR="red"> items;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> keep all current items.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            n &gt;= 0
        <B>local</B>
            i, nb: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            new_table: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            l_content: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_content">content</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
        <B>do</B>
            <B>from</B>
                new_table := <A HREF="../elks/hash_table_flat.html#f_empty_duplicate">empty_duplicate</A> (<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>.<A HREF="../elks/comparable_flat.html#f_max">max</A> (n))
                l_content := <A HREF="../elks/hash_table_flat.html#f_content">content</A>
                l_keys := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
                nb := l_keys.<A HREF="../elks/special_flat.html#f_count">count</A>
            <B>until</B>
                i = nb
            <B>loop</B>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_occupied">occupied</A> (i) <B>then</B>
                    new_table.<A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (l_content.<A HREF="../elks/special_flat.html#f_item">item</A> (i), l_keys.<A HREF="../elks/special_flat.html#f_item">item</A> (i))
                <B>end</B>
                i := i + 1
            <B>end</B>
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                i := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>)
                new_table.<A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (l_content.<A HREF="../elks/special_flat.html#f_item">item</A> (i), <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i))
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_set_content">set_content</A> (new_table.<A HREF="../elks/hash_table_flat.html#f_content">content</A>)
            <A HREF="../elks/hash_table_flat.html#f_set_keys">set_keys</A> (new_table.<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>)
            <A HREF="../elks/hash_table_flat.html#f_set_deleted_marks">set_deleted_marks</A> (new_table.<A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>)
            <A HREF="../elks/hash_table_flat.html#f_set_indexes_map">set_indexes_map</A> (new_table.<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>)
            <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> := new_table.<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
            <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := new_table.<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            count_not_changed: <A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A>
            breathing_space: <A HREF="../elks/hash_table_flat.html#f_count">count</A> &lt; <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
        <B>end</B></A>

    <A NAME="f_default_create"><A HREF="../elks/class_name_translations_flat.html#f_default_create">default_create</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Make table with current translations</FONT>
        <B>local</B>
            i, cnt: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            o, n: <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            cnt := <A HREF="../elks/class_name_translations_flat.html#f_class_translation_count">class_translation_count</A>
            <A HREF="../elks/hash_table_flat.html#f_make">make</A> (cnt)
            <B>from</B>
                i := 0
            <B>until</B>
                i = cnt
            <B>loop</B>
                <B>create</B> o.<A HREF="../elks/readable_string_8_flat.html#f_make_from_c">make_from_c</A> (<A HREF="../elks/class_name_translations_flat.html#f_class_translation_old">class_translation_old</A> (i))
                <B>create</B> n.<A HREF="../elks/readable_string_8_flat.html#f_make_from_c">make_from_c</A> (<A HREF="../elks/class_name_translations_flat.html#f_class_translation_new">class_translation_new</A> (i))
                <A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (n, o)
                i := i + 1
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_make"><A HREF="../elks/hash_table_flat.html#f_make">make</A> (n: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Allocate hash table for at least </FONT>`n'<FONT COLOR="red"> items.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The table will be resized automatically</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> if more than </FONT>`n'<FONT COLOR="red"> items are inserted.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            n_non_negative: n &gt;= 0
        <B>local</B>
            clever: <A HREF="../elks/primes_flat.html">PRIMES</A>
            l_default_value: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_size: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> clever
            l_size := n.<A HREF="../elks/comparable_flat.html#f_max">max</A> (<A HREF="../elks/hash_table_flat.html#f_minimum_capacity">Minimum_capacity</A>)
            l_size := l_size + l_size // 2 + 1
            l_size := clever.<A HREF="../elks/primes_flat.html#f_higher_prime">higher_prime</A> (l_size)
            <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> := l_size
            <B>create</B> <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_make_empty">make_empty</A> (n + 1)
            <B>create</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_make_empty">make_empty</A> (n + 1)
            <B>create</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_make_filled">make_filled</A> (<B>False</B>, n + 1)
            <B>create</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_make_filled">make_filled</A> (<A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>, l_size + 1)
            <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := n + 1
            <A HREF="../elks/hash_table_flat.html#f_count">count</A> := 0
            <A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A> := <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := 0
            <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := l_default_value
            <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> := <B>False</B>
            <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := 0
            <A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := <A HREF="../elks/hash_table_flat.html#f_ht_max_position">Ht_max_position</A>
            <A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A> := l_default_value
            <A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A> := l_default_key
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            breathing_space: n &lt; <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
            more_than_minimum: <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> &gt; <A HREF="../elks/hash_table_flat.html#f_minimum_capacity">Minimum_capacity</A>
            no_status: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_special_status">special_status</A>
        <B>end</B></A>

    <A NAME="f_make_equal"><A HREF="../elks/hash_table_flat.html#f_make_equal">make_equal</A> (n: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Allocate hash table for at least </FONT>`n'<FONT COLOR="red"> items.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The table will be resized automatically</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> if more than </FONT>`n'<FONT COLOR="red"> items are inserted.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT>`~'<FONT COLOR="red"> to compare items.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            n_non_negative: n &gt;= 0
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_make">make</A> (n)
            <A HREF="../elks/container_flat.html#f_compare_objects">compare_objects</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            breathing_space: n &lt; <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
            more_than_minimum: <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> &gt; <A HREF="../elks/hash_table_flat.html#f_minimum_capacity">Minimum_capacity</A>
            no_status: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_special_status">special_status</A>
            compare_objects: <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_at"><A HREF="../elks/hash_table_flat.html#f_at">at</A> <B>alias</B> "@" (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A> <B>assign</B> <A HREF="../elks/class_name_translations_flat.html#f_force">force</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Item associated with </FONT>`key'<FONT COLOR="red">, if present</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> otherwise default value of type </FONT>`G'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red"> as synonym of </FONT><A HREF="../elks/hash_table_flat.html#f_item">item</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>note</B>
            option: stable
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/table_flat.html">TABLE</A>
            valid_key: <A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (key)
        <B>local</B>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>))
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table_flat.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special_flat.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
            <B>end</B>
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            default_value_if_not_present: (<B>not</B> (<A HREF="../elks/hash_table_flat.html#f_has">has</A> (key))) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table_flat.html#f_computed_default_value">computed_default_value</A>)
        <B>end</B></A>

    <A NAME="f_current_keys"><A HREF="../elks/hash_table_flat.html#f_current_keys">current_keys</A>: <A HREF="../elks/array_flat.html">ARRAY</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New array containing actually used keys, from 1 to </FONT><A HREF="../elks/hash_table_flat.html#f_count">count</A>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            j: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            old_iteration_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A> <B>then</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/array_flat.html#f_make_empty">make_empty</A>
            <B>else</B>
                old_iteration_position := <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
                <B>from</B>
                    <A HREF="../elks/hash_table_flat.html#f_start">start</A>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/array_flat.html#f_make_filled">make_filled</A> (<A HREF="../elks/hash_table_flat.html#f_key_for_iteration">key_for_iteration</A>, 1, <A HREF="../elks/hash_table_flat.html#f_count">count</A>)
                    j := 1
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>until</B>
                    <A HREF="../elks/hash_table_flat.html#f_off">off</A>
                <B>loop</B>
                    j := j + 1
                    <B>Result</B>.<A HREF="../elks/array_flat.html#f_put">put</A> (<A HREF="../elks/hash_table_flat.html#f_key_for_iteration">key_for_iteration</A>, j)
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := old_iteration_position
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            good_count: <B>Result</B>.<A HREF="../elks/array_flat.html#f_count">count</A> = <A HREF="../elks/hash_table_flat.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_cursor"><A HREF="../elks/hash_table_flat.html#f_cursor">cursor</A>: <A HREF="../elks/cursor_flat.html">CURSOR</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Current cursor position</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>create</B> {<A HREF="../elks/hash_table_cursor_flat.html">HASH_TABLE_CURSOR</A>} <B>Result</B>.<A HREF="../elks/hash_table_cursor_flat.html#f_make">make</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            cursor_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_found_item"><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A>: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Item, if any, yielded by last search operation</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_generating_type"><A HREF="../elks/any_flat.html#f_generating_type">generating_type</A>: <A HREF="../elks/type_flat.html">TYPE</A> [<B>detachable</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type of current object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (type of which it is a direct instance)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := {<B>detachable</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>}
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            generating_type_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_generator"><A HREF="../elks/any_flat.html#f_generator">generator</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Name of current object's generating class</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (base class of the type of which it is a direct instance)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            generator_not_void: <B>Result</B> /= <B>Void</B>
            generator_not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_has"><A HREF="../elks/hash_table_flat.html#f_has">has</A> (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is there an item in the table with key </FONT>`key'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                    <B>Result</B> := <B>True</B>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table_flat.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <B>Result</B> := <B>True</B>
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special_flat.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
            <B>end</B>
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            default_case: (key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)
        <B>end</B></A>

    <A NAME="f_has_item"><A HREF="../elks/hash_table_flat.html#f_has_item">has_item</A> (v: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does structure include </FONT>`v'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Reference or object equality,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> based on </FONT><A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A><FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            i, nb: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_content: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_content">content</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                <B>Result</B> := (v = <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>)))
            <B>end</B>
            <B>if</B> <B>not</B> <B>Result</B> <B>then</B>
                l_content := <A HREF="../elks/hash_table_flat.html#f_content">content</A>
                nb := l_content.<A HREF="../elks/special_flat.html#f_count">count</A>
                <B>if</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> <B>then</B>
                    <B>from</B>
                    <B>until</B>
                        i = nb <B>or else</B> <B>Result</B>
                    <B>loop</B>
                        <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_occupied">occupied</A> (i) <B>and then</B> (v ~ l_content.<A HREF="../elks/special_flat.html#f_item">item</A> (i))
                        i := i + 1
                    <B>end</B>
                <B>else</B>
                    <B>from</B>
                    <B>until</B>
                        i = nb <B>or else</B> <B>Result</B>
                    <B>loop</B>
                        <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_occupied">occupied</A> (i) <B>and then</B> (v = l_content.<A HREF="../elks/special_flat.html#f_item">item</A> (i))
                        i := i + 1
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A>
            not_found_in_empty: <B>Result</B> <B>implies</B> <B>not</B> <A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_has_key"><A HREF="../elks/hash_table_flat.html#f_has_key">has_key</A> (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is there an item in the table with key </FONT>`key'<FONT COLOR="red">? Set </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to the found item.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            old_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_default_value: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            old_position := <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A>
            <A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A> (key)
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_found">found</A>
            <B>if</B> <B>Result</B> <B>then</B>
                <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_position">position</A>)
            <B>else</B>
                <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := l_default_value
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := old_position
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            default_case: (key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)
            found: <B>Result</B> = <A HREF="../elks/hash_table_flat.html#f_found">found</A>
            item_if_found: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key))
        <B>end</B></A>

    <A NAME="f_hash_code_of"><A HREF="../elks/hash_table_flat.html#f_hash_code_of">hash_code_of</A> (a_key: <B>attached</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hash_code value associated to </FONT>`a_key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := a_key.<A HREF="../elks/readable_string_general_flat.html#f_hash_code">hash_code</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            non_negative: <B>Result</B> &gt;= 0
        <B>end</B></A>

    <A NAME="f_item"><A HREF="../elks/hash_table_flat.html#f_item">item</A> <B>alias</B> "[]" (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A> <B>assign</B> <A HREF="../elks/class_name_translations_flat.html#f_force">force</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Item associated with </FONT>`key'<FONT COLOR="red">, if present</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> otherwise default value of type </FONT>`G'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red"> as synonym of </FONT><A HREF="../elks/hash_table_flat.html#f_at">at</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>note</B>
            option: stable
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/table_flat.html">TABLE</A>
            valid_key: <A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (key)
        <B>local</B>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>))
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table_flat.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special_flat.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
            <B>end</B>
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            default_value_if_not_present: (<B>not</B> (<A HREF="../elks/hash_table_flat.html#f_has">has</A> (key))) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table_flat.html#f_computed_default_value">computed_default_value</A>)
        <B>end</B></A>

    <A NAME="f_item_for_iteration"><A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element at current iteration position</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            not_off: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_off">off</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_iteration_item"><A HREF="../elks/hash_table_flat.html#f_iteration_item">iteration_item</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Entry at position </FONT>`i'
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/readable_indexable_flat.html">READABLE_INDEXABLE</A>
            valid_index: <A HREF="../elks/hash_table_flat.html#f_valid_iteration_index">valid_iteration_index</A> (i)
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i)
        <B>end</B></A>

    <A NAME="f_key_for_iteration"><A HREF="../elks/hash_table_flat.html#f_key_for_iteration">key_for_iteration</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key at current iteration position</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            not_off: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_off">off</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_new_cursor"><A HREF="../elks/hash_table_flat.html#f_new_cursor">new_cursor</A>: <A HREF="../elks/hash_table_iteration_cursor_flat.html">HASH_TABLE_ITERATION_CURSOR</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>, <A HREF="../elks/string_8_flat.html">STRING_8</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Fresh cursor associated with current structure</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT> <A HREF="../elks/iterable_flat.html">ITERABLE</A>
            <B>True</B>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/indexable_iteration_cursor_flat.html#f_make">make</A> (<B>Current</B>)
            <B>Result</B>.<A HREF="../elks/indexable_iteration_cursor_flat.html#f_start">start</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/iterable_flat.html">ITERABLE</A>
            result_attached: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Measurement</FONT>

    <A NAME="f_capacity"><A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of items that may be stored.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_count"><A HREF="../elks/hash_table_flat.html#f_count">count</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of items in table</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_iteration_index_set"><A HREF="../elks/hash_table_flat.html#f_iteration_index_set">iteration_index_set</A>: <A HREF="../elks/integer_interval_flat.html">INTEGER_INTERVAL</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Range of acceptable indexes</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/integer_interval_flat.html#f_make">make</A> (<A HREF="../elks/hash_table_flat.html#f_next_iteration_position">next_iteration_position</A> (-1), <A HREF="../elks/hash_table_flat.html#f_previous_iteration_position">previous_iteration_position</A> (<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>))
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/readable_indexable_flat.html">READABLE_INDEXABLE</A>
            not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_occurrences"><A HREF="../elks/hash_table_flat.html#f_occurrences">occurrences</A> (v: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of table items equal to </FONT>`v'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            old_iteration_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            old_iteration_position := <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
            <B>if</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> <B>then</B>
                <B>from</B>
                    <A HREF="../elks/hash_table_flat.html#f_start">start</A>
                <B>until</B>
                    <A HREF="../elks/hash_table_flat.html#f_off">off</A>
                <B>loop</B>
                    <B>if</B> <A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A> ~ v <B>then</B>
                        <B>Result</B> := <B>Result</B> + 1
                    <B>end</B>
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    <A HREF="../elks/hash_table_flat.html#f_start">start</A>
                <B>until</B>
                    <A HREF="../elks/hash_table_flat.html#f_off">off</A>
                <B>loop</B>
                    <B>if</B> <A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A> = v <B>then</B>
                        <B>Result</B> := <B>Result</B> + 1
                    <B>end</B>
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>end</B>
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := old_iteration_position
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/bag_flat.html">BAG</A>
            non_negative_occurrences: <B>Result</B> &gt;= 0
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Comparison</FONT>

    <A NAME="f_deep_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> or attached to isomorphic object structures?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            shallow_implies_deep: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (a, b) <B>implies</B> <B>Result</B>
            both_or_none_void: (a = <B>Void</B>) <B>implies</B> (<B>Result</B> = (b = <B>Void</B>))
            same_type: (<B>Result</B> <B>and</B> (a /= <B>Void</B>)) <B>implies</B> (b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (b))
            symmetric: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (b, a)
        <B>end</B></A>

    <A NAME="f_disjoint"><A HREF="../elks/hash_table_flat.html#f_disjoint">disjoint</A> (other: <A HREF="../elks/hash_table_flat.html">HASH_TABLE</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>, <A HREF="../elks/string_8_flat.html">STRING_8</A>]): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`Current'<FONT COLOR="red"> and </FONT>`other'<FONT COLOR="red"> disjoint on their keys?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT><A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A><FONT COLOR="red"> for comparison.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A> <B>or else</B> other.<A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A> <B>or else</B> <B>not</B> <B>across</B>
                other <B>as</B> o
            <B>some</B>
                <A HREF="../elks/hash_table_flat.html#f_has">has</A> (o.<A HREF="../elks/hash_table_iteration_cursor_flat.html#f_key">key</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_equal">equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void or attached</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to objects considered equal?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (a = <B>Void</B> <B>and</B> b = <B>Void</B>) <B>or else</B> ((a /= <B>Void</B> <B>and</B> b /= <B>Void</B>) <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (b))
        <B>end</B></A>

    <A NAME="f_is_deep_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (other: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`Current'<FONT COLOR="red"> and </FONT>`other'<FONT COLOR="red"> attached to isomorphic object structures?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            shallow_implies_deep: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other) <B>implies</B> <B>Result</B>
            same_type: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
            symmetric: <B>Result</B> <B>implies</B> other.<A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (<B>Current</B>)
        <B>end</B></A>

    <A NAME="f_is_equal"><A HREF="../elks/hash_table_flat.html#f_is_equal">is_equal</A> (other: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does table contain the same information as </FONT>`other'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A> = other.<A HREF="../elks/hash_table_flat.html#f_count">count</A> <B>and then</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> = other.<A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> <B>and then</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> = other.<A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                <B>Result</B> := <B>True</B>
                <B>across</B>
                    <B>Current</B> <B>as</B> l_c
                <B>until</B>
                    <B>not</B> <B>Result</B>
                <B>loop</B>
                    other.<A HREF="../elks/hash_table_flat.html#f_search">search</A> (l_c.<A HREF="../elks/hash_table_iteration_cursor_flat.html#f_key">key</A>)
                    <B>if</B> other.<A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>then</B>
                        <B>if</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> <B>then</B>
                            <B>Result</B> := l_c.<A HREF="../elks/hash_table_iteration_cursor_flat.html#f_item">item</A> ~ other.<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A>
                        <B>else</B>
                            <B>Result</B> := l_c.<A HREF="../elks/hash_table_iteration_cursor_flat.html#f_item">item</A> = other.<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A>
                        <B>end</B>
                    <B>else</B>
                        <B>Result</B> := <B>False</B>
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            symmetric: <B>Result</B> <B>implies</B> other ~ <B>Current</B>
            consistent: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other) <B>implies</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_same_keys"><A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A> (a_search_key, a_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does </FONT>`a_search_key'<FONT COLOR="red"> equal to </FONT>`a_key'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            valid_search_key: <A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (a_search_key)
            valid_key: <A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (a_key)
        <B>do</B>
            <B>Result</B> := a_search_key ~ a_key
        <B>end</B></A>

    <A NAME="f_standard_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void or attached to</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> field-by-field identical objects of the same type?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default object comparison criterion.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (a = <B>Void</B> <B>and</B> b = <B>Void</B>) <B>or else</B> ((a /= <B>Void</B> <B>and</B> b /= <B>Void</B>) <B>and then</B> a.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (b))
        <B>end</B></A>

    <A NAME="f_standard_is_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`other'<FONT COLOR="red"> attached to an object of the same type</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> as current object, and field-by-field identical to it?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            same_type: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
            symmetric: <B>Result</B> <B>implies</B> other.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (<B>Current</B>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_after"><A HREF="../elks/hash_table_flat.html#f_after">after</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is cursor past last item?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red"> as synonym of </FONT><A HREF="../elks/hash_table_flat.html#f_off">off</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_is_off_position">is_off_position</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_changeable_comparison_criterion"><A HREF="../elks/container_flat.html#f_changeable_comparison_criterion">changeable_comparison_criterion</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> May </FONT><A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A><FONT COLOR="red"> be changed?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Answer: yes by default.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <B>True</B>
        <B>end</B></A>

    <A NAME="f_conflict"><A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation cause a conflict?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> = <A HREF="../elks/hash_table_flat.html#f_conflict_constant">Conflict_constant</A>)
        <B>end</B></A>

    <A NAME="f_conforms_to"><A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (other: <A HREF="../elks/any_flat.html">ANY</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does type of current object conform to type</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of </FONT>`other'<FONT COLOR="red"> (as per Eiffel: The Language, chapter 13)?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>end</B></A>

    <A NAME="f_empty"><A HREF="../elks/container_flat.html#f_empty">empty</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
        <B>obsolete</B> "ELKS 2000: Use `is_empty' instead"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is there no element?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_extendible"><A HREF="../elks/hash_table_flat.html#f_extendible">Extendible</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A> = <B>False</B></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> May new items be added?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_found"><A HREF="../elks/hash_table_flat.html#f_found">found</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation find the item sought?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> = <A HREF="../elks/hash_table_flat.html#f_found_constant">Found_constant</A>)
        <B>end</B></A>

    <A NAME="f_full"><A HREF="../elks/hash_table_flat.html#f_full">Full</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A> = <B>False</B></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is structure filled to capacity?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_inserted"><A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation insert an item?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> = <A HREF="../elks/hash_table_flat.html#f_inserted_constant">Inserted_constant</A>)
        <B>end</B></A>

    <A NAME="f_is_empty"><A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is structure empty?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/finite_flat.html">FINITE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT> <A HREF="../elks/container_flat.html">CONTAINER</A>
            <B>True</B>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = 0)
        <B>end</B></A>

    <A NAME="f_is_inserted"><A HREF="../elks/collection_flat.html#f_is_inserted">is_inserted</A> (v: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Has </FONT>`v'<FONT COLOR="red"> been inserted by the most recent insertion?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (By default, the value returned is equivalent to calling </FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`has (v)'<FONT COLOR="red">. However, descendants might be able to provide more</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> efficient implementations.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_has_item">has_item</A> (v)
        <B>end</B></A>

    <A NAME="f_not_found"><A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation fail to find the item sought?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> = <A HREF="../elks/hash_table_flat.html#f_not_found_constant">Not_found_constant</A>)
        <B>end</B></A>

    <A NAME="f_object_comparison"><A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Must search operations use </FONT><A HREF="../elks/any_flat.html#f_equal">equal</A><FONT COLOR="red"> rather than </FONT>`='
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> for comparing references? (Default: no, use </FONT>`='<FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A><FONT COLOR="red">)</FONT>

    <A NAME="f_off"><A HREF="../elks/hash_table_flat.html#f_off">off</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is cursor past last item?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red"> as synonym of </FONT><A HREF="../elks/hash_table_flat.html#f_after">after</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_is_off_position">is_off_position</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_prunable"><A HREF="../elks/hash_table_flat.html#f_prunable">prunable</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> May items be removed?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <B>True</B>
        <B>end</B></A>

    <A NAME="f_removed"><A HREF="../elks/hash_table_flat.html#f_removed">removed</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation remove an item?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> = <A HREF="../elks/hash_table_flat.html#f_removed_constant">Removed_constant</A>)
        <B>end</B></A>

    <A NAME="f_replaced"><A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation replace an item?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> = <A HREF="../elks/hash_table_flat.html#f_replaced_constant">Replaced_constant</A>)
        <B>end</B></A>

    <A NAME="f_same_type"><A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other: <A HREF="../elks/any_flat.html">ANY</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is type of current object identical to type of </FONT>`other'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (<A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (other) <B>and</B> other.<A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (<B>Current</B>))
        <B>end</B></A>

    <A NAME="f_valid_cursor"><A HREF="../elks/hash_table_flat.html#f_valid_cursor">valid_cursor</A> (c: <A HREF="../elks/cursor_flat.html">CURSOR</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Can cursor be moved to position </FONT>`c'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            c_not_void: c /= <B>Void</B>
        <B>local</B>
            i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/hash_table_cursor_flat.html">HASH_TABLE_CURSOR</A>} c <B>as</B> ht_cursor <B>then</B>
                i := ht_cursor.<A HREF="../elks/hash_table_cursor_flat.html#f_position">position</A>
                <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_is_off_position">is_off_position</A> (i) <B>or else</B> <A HREF="../elks/hash_table_flat.html#f_truly_occupied">truly_occupied</A> (i)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_valid_iteration_index"><A HREF="../elks/hash_table_flat.html#f_valid_iteration_index">valid_iteration_index</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`i'<FONT COLOR="red"> a valid index?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_truly_occupied">truly_occupied</A> (i)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/readable_indexable_flat.html">READABLE_INDEXABLE</A>
            only_if_in_index_set: <B>Result</B> <B>implies</B> ((i &gt;= <A HREF="../elks/hash_table_flat.html#f_iteration_index_set">iteration_index_set</A>.<A HREF="../elks/integer_interval_flat.html#f_lower">lower</A>) <B>and</B> (i &lt;= <A HREF="../elks/hash_table_flat.html#f_iteration_index_set">iteration_index_set</A>.<A HREF="../elks/integer_interval_flat.html#f_upper">upper</A>))
        <B>end</B></A>

    <A NAME="f_valid_key"><A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (k: <A HREF="../elks/string_8_flat.html">STRING_8</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`k'<FONT COLOR="red"> a valid key?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <B>True</B>
            <B>debug</B> ("prevent_hash_table_catcall")
                <B>if</B> <B>not</B> ({<A HREF="../elks/string_8_flat.html">STRING_8</A>}).<A HREF="../elks/type_flat.html#f_is_expanded">is_expanded</A> <B>and then</B> <B>attached</B> k <B>then</B>
                    <B>Result</B> := k.<A HREF="../elks/any_flat.html#f_generating_type">generating_type</A> ~ {<B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>}
                <B>end</B>
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status setting</FONT>

    <A NAME="f_compare_objects"><A HREF="../elks/container_flat.html#f_compare_objects">compare_objects</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Ensure that future search operations will use </FONT><A HREF="../elks/any_flat.html#f_equal">equal</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> rather than </FONT>`='<FONT COLOR="red"> for comparing references.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A>
            changeable_comparison_criterion: <A HREF="../elks/container_flat.html#f_changeable_comparison_criterion">changeable_comparison_criterion</A>
        <B>do</B>
            <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> := <B>True</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A>
            <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A>
        <B>end</B></A>

    <A NAME="f_compare_references"><A HREF="../elks/container_flat.html#f_compare_references">compare_references</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Ensure that future search operations will use </FONT>`='
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> rather than </FONT><A HREF="../elks/any_flat.html#f_equal">equal</A><FONT COLOR="red"> for comparing references.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A>
            changeable_comparison_criterion: <A HREF="../elks/container_flat.html#f_changeable_comparison_criterion">changeable_comparison_criterion</A>
        <B>do</B>
            <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> := <B>False</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/container_flat.html">CONTAINER</A>
            reference_comparison: <B>not</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cursor movement</FONT>

    <A NAME="f_forth"><A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Advance cursor to next occupied position,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> or </FONT><A HREF="../elks/hash_table_flat.html#f_off">off</A><FONT COLOR="red"> if no such position remains.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            not_off: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_off">off</A>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := <A HREF="../elks/hash_table_flat.html#f_next_iteration_position">next_iteration_position</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_go_to"><A HREF="../elks/hash_table_flat.html#f_go_to">go_to</A> (c: <A HREF="../elks/cursor_flat.html">CURSOR</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Move to position </FONT>`c'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            c_not_void: c /= <B>Void</B>
            valid_cursor: <A HREF="../elks/hash_table_flat.html#f_valid_cursor">valid_cursor</A> (c)
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/hash_table_cursor_flat.html">HASH_TABLE_CURSOR</A>} c <B>as</B> ht_cursor <B>then</B>
                <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := ht_cursor.<A HREF="../elks/hash_table_cursor_flat.html#f_position">position</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_search"><A HREF="../elks/hash_table_flat.html#f_search">search</A> (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Search for item of key </FONT>`key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If found, set </FONT><A HREF="../elks/hash_table_flat.html#f_found">found</A><FONT COLOR="red"> to true, and set</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to item associated with </FONT>`key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            old_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_default_value: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            old_position := <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A>
            <A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>then</B>
                <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_position">position</A>)
            <B>else</B>
                <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := l_default_value
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := old_position
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            found_or_not_found: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
            item_if_found: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key))
        <B>end</B></A>

    <A NAME="f_search_item"><A HREF="../elks/hash_table_flat.html#f_search_item">search_item</A>: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>obsolete</B> "Use found_item instead."
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A>
        <B>end</B></A>

    <A NAME="f_start"><A HREF="../elks/hash_table_flat.html#f_start">start</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Bring cursor to first position.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := <A HREF="../elks/hash_table_flat.html#f_next_iteration_position">next_iteration_position</A> (-1)
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/hash_table_iteration_cursor_flat.html">HASH_TABLE_ITERATION_CURSOR</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cursor movement</FONT>

    <A NAME="f_next_iteration_position"><A HREF="../elks/hash_table_flat.html#f_next_iteration_position">next_iteration_position</A> (a_position: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>): <B>like</B> <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Given an iteration position, advanced to the next one taking into account deleted</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> slots in the </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red"> and </FONT><A HREF="../elks/hash_table_flat.html#f_keys">keys</A><FONT COLOR="red"> structures.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            a_position_big_enough: a_position &gt;= -1
            a_position_small_enough: a_position &lt; <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
        <B>local</B>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_table_size: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>Result</B> := a_position + 1
            l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_table_size := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
            <B>from</B>
            <B>until</B>
                <B>Result</B> &gt;= l_table_size <B>or else</B> <B>not</B> l_deleted_marks.<A HREF="../elks/special_flat.html#f_item">item</A> (<B>Result</B>)
            <B>loop</B>
                <B>Result</B> := <B>Result</B> + 1
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_previous_iteration_position"><A HREF="../elks/hash_table_flat.html#f_previous_iteration_position">previous_iteration_position</A> (a_position: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>): <B>like</B> <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Given an iteration position, go to the previous one taking into account deleted</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> slots in the </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red"> and </FONT><A HREF="../elks/hash_table_flat.html#f_keys">keys</A><FONT COLOR="red"> structures.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            a_position_big_enough: a_position &gt;= 0
            a_position_small_enough: a_position &lt;= <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
        <B>local</B>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_table_size: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>Result</B> := a_position - 1
            l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_table_size := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
            <B>from</B>
            <B>until</B>
                <B>Result</B> &lt;= 0 <B>or else</B> <B>not</B> l_deleted_marks.<A HREF="../elks/special_flat.html#f_item">item</A> (<B>Result</B>)
            <B>loop</B>
                <B>Result</B> := <B>Result</B> - 1
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element change</FONT>

    <A NAME="f_extend"><A HREF="../elks/class_name_translations_flat.html#f_extend">extend</A> (new: <A HREF="../elks/string_8_flat.html">STRING_8</A>; key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assuming there is no item of key </FONT>`key'<FONT COLOR="red">,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> insert </FONT>`new'<FONT COLOR="red"> with </FONT>`key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A><FONT COLOR="red">.</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            not_present: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key)
        <B>do</B>
            <B>Precursor</B> (new, key)
            <A HREF="../elks/class_name_translations_flat.html#f_add_translation">add_translation</A> (new, key)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            inserted: <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A>
            insertion_done: <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = new
            one_more: <A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A> + 1
            default_property: <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> = ((key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>or</B> (<B>old</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>))
        <B>end</B></A>

    <A NAME="f_fill"><A HREF="../elks/collection_flat.html#f_fill">fill</A> (other: <A HREF="../elks/container_flat.html">CONTAINER</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>])
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Fill with as many items of </FONT>`other'<FONT COLOR="red"> as possible.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The representations of </FONT>`other'<FONT COLOR="red"> and current structure</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> need not be the same.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            other_not_void: other /= <B>Void</B>
            extendible: <A HREF="../elks/hash_table_flat.html#f_extendible">Extendible</A>
        <B>local</B>
            lin_rep: <A HREF="../elks/linear_flat.html">LINEAR</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]
        <B>do</B>
            lin_rep := other.<A HREF="../elks/container_flat.html#f_linear_representation">linear_representation</A>
            <B>from</B>
                lin_rep.<A HREF="../elks/traversable_flat.html#f_start">start</A>
            <B>until</B>
                <B>not</B> <A HREF="../elks/hash_table_flat.html#f_extendible">Extendible</A> <B>or else</B> lin_rep.<A HREF="../elks/linear_flat.html#f_off">off</A>
            <B>loop</B>
                <A HREF="../elks/hash_table_flat.html#f_collection_extend">collection_extend</A> (lin_rep.<A HREF="../elks/traversable_flat.html#f_item">item</A>)
                lin_rep.<A HREF="../elks/linear_flat.html#f_forth">forth</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_force"><A HREF="../elks/class_name_translations_flat.html#f_force">force</A> (new: <A HREF="../elks/string_8_flat.html">STRING_8</A>; key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Update table so that </FONT>`new'<FONT COLOR="red"> will be the item associated</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with </FONT>`key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If there was an item for that key, set </FONT><A HREF="../elks/hash_table_flat.html#f_found">found</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> and set </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to that item.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If there was none, set </FONT><A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A><FONT COLOR="red"> and set</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to the default value.</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/table_flat.html">TABLE</A>
            valid_key: <A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (key)
        <B>do</B>
            <B>Precursor</B> (new, key)
            <A HREF="../elks/class_name_translations_flat.html#f_add_translation">add_translation</A> (new, key)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/table_flat.html">TABLE</A>
            inserted: <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = new
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            insertion_done: <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = new
            now_present: <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key)
            found_or_not_found: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
            not_found_if_was_not_present: <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A> = <B>not</B> (<B>old</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key))
            same_count_or_one_more: (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A>) <B>or</B> (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A> + 1)
            found_item_is_old_item: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (key)))
            default_value_if_not_found: <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table_flat.html#f_computed_default_value">computed_default_value</A>)
            default_property: <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> = ((key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>or</B> ((key /= <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>and</B> (<B>old</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)))
        <B>end</B></A>

    <A NAME="f_merge"><A HREF="../elks/hash_table_flat.html#f_merge">merge</A> (other: <A HREF="../elks/hash_table_flat.html">HASH_TABLE</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>, <A HREF="../elks/string_8_flat.html">STRING_8</A>])
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Merge </FONT>`other'<FONT COLOR="red"> into Current. If </FONT>`other'<FONT COLOR="red"> has some elements</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with same key as in </FONT>`Current'<FONT COLOR="red">, replace them by one from</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <B>from</B>
                other.<A HREF="../elks/hash_table_flat.html#f_start">start</A>
            <B>until</B>
                other.<A HREF="../elks/hash_table_flat.html#f_after">after</A>
            <B>loop</B>
                <A HREF="../elks/class_name_translations_flat.html#f_force">force</A> (other.<A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A>, other.<A HREF="../elks/hash_table_flat.html#f_key_for_iteration">key_for_iteration</A>)
                other.<A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            inserted: other.<A HREF="../elks/hash_table_flat.html#f_current_keys">current_keys</A>.<A HREF="../elks/array_flat.html#f_linear_representation">linear_representation</A>.<A HREF="../elks/linear_flat.html#f_for_all">for_all</A> (<B>agent</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A>)
        <B>end</B></A>

    <A NAME="f_put"><A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (new: <A HREF="../elks/string_8_flat.html">STRING_8</A>; key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Insert </FONT>`new'<FONT COLOR="red"> with </FONT>`key'<FONT COLOR="red"> if there is no other item</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> associated with the same key.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A><FONT COLOR="red"> if and only if an insertion has</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> been made (i.e. </FONT>`key'<FONT COLOR="red"> was not present).</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If so, set </FONT><A HREF="../elks/hash_table_flat.html#f_position">position</A><FONT COLOR="red"> to the insertion position.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If not, set </FONT><A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> In either case, set </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to the item</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> now associated with </FONT>`key'<FONT COLOR="red"> (previous item if</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> there was one, </FONT>`new'<FONT COLOR="red"> otherwise).</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/table_flat.html">TABLE</A>
            valid_key: <A HREF="../elks/hash_table_flat.html#f_valid_key">valid_key</A> (key)
        <B>do</B>
            <B>Precursor</B> (new, key)
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>then</B>
                <A HREF="../elks/class_name_translations_flat.html#f_add_translation">add_translation</A> (new, key)
            <B>end</B>
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            conflict_or_inserted: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A>
            insertion_done: <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>implies</B> <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = new
            now_present: <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>implies</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key)
            one_more_if_inserted: <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A> + 1)
            unchanged_if_conflict: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A>)
            same_item_if_conflict: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (key)))
            found_item_associated_with_key: <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key)
            new_item_if_inserted: <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = new)
            old_item_if_conflict: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (key)))
            default_property: <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> = ((<A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>and</B> (key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>)) <B>or</B> ((<A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>or</B> (key /= <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>)) <B>and</B> (<B>old</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)))
        <B>end</B></A>

    <A NAME="f_replace"><A HREF="../elks/class_name_translations_flat.html#f_replace">replace</A> (new: <A HREF="../elks/string_8_flat.html">STRING_8</A>; key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Replace item at </FONT>`key'<FONT COLOR="red">, if present,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with </FONT>`new'<FONT COLOR="red">; do not change associated key.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A><FONT COLOR="red"> if and only if a replacement has been made</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (i.e. </FONT>`key'<FONT COLOR="red"> was present); otherwise set </FONT><A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to the item previously associated</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with </FONT>`key'<FONT COLOR="red"> (default value if there was none).</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key) <B>then</B>
                <B>Precursor</B> (new, key)
                <A HREF="../elks/class_name_translations_flat.html#f_add_translation">add_translation</A> (new, key)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            replaced_or_not_found: <A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
            insertion_done: <A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>implies</B> <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = new
            no_change_if_not_found: <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A> <B>implies</B> <A HREF="../elks/hash_table_flat.html#f_item">item</A> (key) = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (key))
            found_item_is_old_item: <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (key))
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element change</FONT>

    <A NAME="f_replace_key"><A HREF="../elks/hash_table_flat.html#f_replace_key">replace_key</A> (new_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>; old_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If there is an item of key </FONT>`old_key'<FONT COLOR="red"> and no item of key</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`new_key'<FONT COLOR="red">, replace the former's key by </FONT>`new_key'<FONT COLOR="red">,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> set </FONT><A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A><FONT COLOR="red">, and set </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to the item</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> previously associated with </FONT>`old_key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Otherwise set </FONT><A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A><FONT COLOR="red"> or </FONT><A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A><FONT COLOR="red"> respectively.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If </FONT><A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A><FONT COLOR="red">, set </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to the item previously</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> associated with </FONT>`new_key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To choose between various insert/replace procedures,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> see </FONT>`instructions'<FONT COLOR="red"> in the Indexing clause.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_item: <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A> (new_key)
            <B>if</B> <B>not</B> <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>then</B>
                <A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A> (old_key)
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>then</B>
                    l_item := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_position">position</A>)
                    <A HREF="../elks/hash_table_flat.html#f_remove">remove</A> (old_key)
                    <A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (l_item, new_key)
                    <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_replaced_constant">Replaced_constant</A>
                <B>end</B>
            <B>else</B>
                <A HREF="../elks/hash_table_flat.html#f_set_conflict">set_conflict</A>
                <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_position">position</A>)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            same_count: <A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A>
            replaced_or_conflict_or_not_found: <A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
            old_absent: (<A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>and</B> <B>not</B> <A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A> (new_key, old_key)) <B>implies</B> (<B>not</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (old_key))
            new_present: (<A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A>) = <A HREF="../elks/hash_table_flat.html#f_has">has</A> (new_key)
            new_item: <A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (new_key) = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (old_key)))
            not_found_implies_no_old_key: <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A> <B>implies</B> <B>old</B> (<B>not</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (old_key))
            conflict_iff_already_present: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_has">has</A> (new_key))
            not_inserted_if_conflict: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (new_key) = <B>old</B> (<A HREF="../elks/hash_table_flat.html#f_item">item</A> (new_key)))
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Removal</FONT>

    <A NAME="f_clear_all"><A HREF="../elks/hash_table_flat.html#f_clear_all">clear_all</A>
        <B>obsolete</B> "Use `wipe_out' instead."
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/class_name_translations_flat.html#f_wipe_out">wipe_out</A>
        <B>end</B></A>

    <A NAME="f_prune"><A HREF="../elks/hash_table_flat.html#f_prune">prune</A> (v: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove first occurrence of </FONT>`v'<FONT COLOR="red">, if any,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> after cursor position.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Move cursor to right neighbor.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (or after if no right neighbor or </FONT>`v'<FONT COLOR="red"> does not occur)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            prunable: <A HREF="../elks/hash_table_flat.html#f_prunable">prunable</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> <B>then</B>
                <B>from</B>
                <B>until</B>
                    <A HREF="../elks/hash_table_flat.html#f_after">after</A> <B>or else</B> <A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A> ~ v
                <B>loop</B>
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                <B>until</B>
                    <A HREF="../elks/hash_table_flat.html#f_after">after</A> <B>or else</B> <A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A> = v
                <B>loop</B>
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>end</B>
            <B>end</B>
            <B>if</B> <B>not</B> <A HREF="../elks/hash_table_flat.html#f_after">after</A> <B>then</B>
                <A HREF="../elks/hash_table_flat.html#f_remove">remove</A> (<A HREF="../elks/hash_table_flat.html#f_key_for_iteration">key_for_iteration</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_wipe_out"><A HREF="../elks/class_name_translations_flat.html#f_wipe_out">wipe_out</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reset all items to default values; reset status.</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            prunable: <A HREF="../elks/hash_table_flat.html#f_prunable">prunable</A>
        <B>do</B>
            <B>Precursor</B>
            <A HREF="../elks/class_name_translations_flat.html#f_class_translation_clear">class_translation_clear</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            wiped_out: <A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            position_equal_to_zero: <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> = 0
            count_equal_to_zero: <A HREF="../elks/hash_table_flat.html#f_count">count</A> = 0
            has_default_set: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>
            no_status: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_special_status">special_status</A>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Removal</FONT>

    <A NAME="f_prune_all"><A HREF="../elks/collection_flat.html#f_prune_all">prune_all</A> (v: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove all occurrences of </FONT>`v'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Reference or object equality,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> based on </FONT><A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A><FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            prunable: <A HREF="../elks/hash_table_flat.html#f_prunable">prunable</A>
        <B>do</B>
            <B>from</B>
            <B>until</B>
                <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has_item">has_item</A> (v)
            <B>loop</B>
                <A HREF="../elks/hash_table_flat.html#f_prune">prune</A> (v)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            no_more_occurrences: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has_item">has_item</A> (v)
        <B>end</B></A>

    <A NAME="f_remove"><A HREF="../elks/hash_table_flat.html#f_remove">remove</A> (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove item associated with </FONT>`key'<FONT COLOR="red">, if present.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/hash_table_flat.html#f_removed">removed</A><FONT COLOR="red"> if and only if an item has been</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> removed (i.e. </FONT>`key'<FONT COLOR="red"> was present);</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> if so, set </FONT><A HREF="../elks/hash_table_flat.html#f_position">position</A><FONT COLOR="red"> to index of removed element.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If not, set </FONT><A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reset </FONT><A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A><FONT COLOR="red"> to its default value if </FONT><A HREF="../elks/hash_table_flat.html#f_removed">removed</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_default_value: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_pos: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_position">position</A>
            l_nb_removed_items: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>then</B>
                l_pos := <A HREF="../elks/hash_table_flat.html#f_position">position</A>
                <B>if</B> key = l_default_key <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> := <B>False</B>
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_put">put</A> (<B>True</B>, l_pos)
                <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_put">put</A> (- l_pos + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>, <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A>)
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> = l_pos <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_count">count</A> := <A HREF="../elks/hash_table_flat.html#f_count">count</A> - 1
                <A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := l_pos.<A HREF="../elks/comparable_flat.html#f_min">min</A> (<A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>)
                <B>if</B> (<A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> = <A HREF="../elks/hash_table_flat.html#f_count">count</A>) <B>then</B>
                    l_nb_removed_items := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_count">count</A> - <A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>
                    <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_remove_tail">remove_tail</A> (l_nb_removed_items)
                    <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_remove_tail">remove_tail</A> (l_nb_removed_items)
                    <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_fill_with">fill_with</A> (<B>False</B>, <A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>, <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_count">count</A> - 1)
                    <A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A> := l_default_value
                    <A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A> := l_default_key
                    <A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := <A HREF="../elks/hash_table_flat.html#f_ht_max_position">Ht_max_position</A>
                <B>elseif</B> <B>attached</B> <A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A> <B>as</B> l_item <B>and</B> <B>attached</B> <A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A> <B>as</B> l_key <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_put">put</A> (l_item, l_pos)
                    <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_put">put</A> (l_key, l_pos)
                <B>else</B>
                    <A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A> := <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                    <A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A> := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_removed_constant">Removed_constant</A>
                <A HREF="../elks/hash_table_flat.html#f_found_item">found_item</A> := l_default_value
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            removed_or_not_found: <A HREF="../elks/hash_table_flat.html#f_removed">removed</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
            not_present: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key)
            one_less: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A> - 1)
            default_case: (key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<B>not</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)
            non_default_case: (key /= <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Transformation</FONT>

    <A NAME="f_correct_mismatch"><A HREF="../elks/hash_table_flat.html#f_correct_mismatch">correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Attempt to correct object mismatch during retrieve using </FONT><A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_old_deleted_marks: <B>detachable</B> <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/boolean_flat.html">BOOLEAN</A>]
            i, l_capacity, l_count: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_new_table: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            l_default_item: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A>
            l_default_key: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A>
        <B>do</B>
            <B>if</B> <B>not</B> <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_has">has</A> ("hash_table_version_64") <B>then</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/array_flat.html">ARRAY</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]} <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_item">item</A> ("content") <B>as</B> array_content <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_content">content</A> := array_content.<A HREF="../elks/to_special_flat.html#f_area">area</A>
                <B>end</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/array_flat.html">ARRAY</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]} <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_item">item</A> ("keys") <B>as</B> array_keys <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_keys">keys</A> := array_keys.<A HREF="../elks/to_special_flat.html#f_area">area</A>
                <B>end</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/array_flat.html">ARRAY</A> [<A HREF="../elks/boolean_flat.html">BOOLEAN</A>]} <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_item">item</A> ("deleted_marks") <B>as</B> array_marks <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A> := array_marks.<A HREF="../elks/to_special_flat.html#f_area">area</A>
                <B>end</B>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A> /= <B>Void</B> <B>and</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A> /= <B>Void</B> <B>then</B>
                    <B>if</B> <B>not</B> <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_has">has</A> ("hash_table_version_57") <B>then</B>
                        <B>if</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_count">count</A> /= <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> <B>then</B>
                            l_old_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
                            <B>create</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_make_empty">make_empty</A> (<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>)
                            <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_copy_data">copy_data</A> (l_old_deleted_marks, 0, 0, l_old_deleted_marks.<A HREF="../elks/special_flat.html#f_count">count</A>)
                        <B>end</B>
                    <B>end</B>
                <B>end</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>} <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_item">item</A> ("count") <B>as</B> l_retrieved_count <B>then</B>
                    l_count := l_retrieved_count
                <B>end</B>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_content">content</A> = <B>Void</B> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A> = <B>Void</B> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A> = <B>Void</B> <B>then</B>
                    <B>Precursor</B> {<A HREF="../elks/mismatch_corrector_flat.html">MISMATCH_CORRECTOR</A>}
                <B>else</B>
                    <B>from</B>
                        l_capacity := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
                        l_new_table := <A HREF="../elks/hash_table_flat.html#f_empty_duplicate">empty_duplicate</A> (l_count)
                    <B>until</B>
                        i = l_capacity
                    <B>loop</B>
                        <B>if</B> <B>attached</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i) <B>as</B> l_key_item <B>and then</B> l_key_item /= l_default_key <B>then</B>
                            l_new_table.<A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (<A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i), l_key_item)
                        <B>end</B>
                        i := i + 1
                    <B>end</B>
                    <B>if</B> <B>attached</B> {<A HREF="../elks/boolean_flat.html">BOOLEAN</A>} <A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table_flat.html#f_item">item</A> ("has_default") <B>as</B> l_bool <B>and then</B> l_bool <B>then</B>
                        l_new_table.<A HREF="../elks/class_name_translations_flat.html#f_put">put</A> (<A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_capacity">capacity</A> - 1), <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (l_capacity - 1))
                    <B>end</B>
                    <A HREF="../elks/hash_table_flat.html#f_set_content">set_content</A> (l_new_table.<A HREF="../elks/hash_table_flat.html#f_content">content</A>)
                    <A HREF="../elks/hash_table_flat.html#f_set_keys">set_keys</A> (l_new_table.<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>)
                    <A HREF="../elks/hash_table_flat.html#f_set_deleted_marks">set_deleted_marks</A> (l_new_table.<A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>)
                    <A HREF="../elks/hash_table_flat.html#f_set_indexes_map">set_indexes_map</A> (l_new_table.<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>)
                    <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> := l_new_table.<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                    <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := l_new_table.<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
                    <A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A> := l_new_table.<A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A>
                    <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := l_new_table.<A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A>
                    <A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := <A HREF="../elks/hash_table_flat.html#f_ht_max_position">Ht_max_position</A>
                    <A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A> := l_default_item
                    <A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A> := l_default_key
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_control">control</A> := 0
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_hash_table_version_64"><A HREF="../elks/hash_table_flat.html#f_hash_table_version_64">hash_table_version_64</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Fake attribute for versioning purposes. Used in </FONT><A HREF="../elks/hash_table_flat.html#f_correct_mismatch">correct_mismatch</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Conversion</FONT>

    <A NAME="f_linear_representation"><A HREF="../elks/hash_table_flat.html#f_linear_representation">linear_representation</A>: <A HREF="../elks/arrayed_list_flat.html">ARRAYED_LIST</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Representation as a linear structure</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT> <A HREF="../elks/container_flat.html">CONTAINER</A>
            <B>True</B>
        <B>local</B>
            old_iteration_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            old_iteration_position := <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>
            <B>from</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list_flat.html#f_make">make</A> (<A HREF="../elks/hash_table_flat.html#f_count">count</A>)
                <A HREF="../elks/hash_table_flat.html#f_start">start</A>
            <B>until</B>
                <A HREF="../elks/hash_table_flat.html#f_off">off</A>
            <B>loop</B>
                <B>Result</B>.<A HREF="../elks/arrayed_list_flat.html#f_extend">extend</A> (<A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A>)
                <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A> := old_iteration_position
        <B>ensure then</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            result_exists: <B>Result</B> /= <B>Void</B>
            good_count: <B>Result</B>.<A HREF="../elks/arrayed_list_flat.html#f_count">count</A> = <A HREF="../elks/hash_table_flat.html#f_count">count</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_clone">clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void; otherwise new object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> equal to </FONT>`other'
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> For non-void </FONT>`other'<FONT COLOR="red">, </FONT><A HREF="../elks/any_flat.html#f_clone">clone</A><FONT COLOR="red"> calls </FONT><A HREF="../elks/hash_table_flat.html#f_copy">copy</A><FONT COLOR="red">;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to change copying/cloning semantics, redefine </FONT><A HREF="../elks/hash_table_flat.html#f_copy">copy</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_twin">twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            equal: <B>Result</B> ~ other
        <B>end</B></A>

    <A NAME="f_copy"><A HREF="../elks/hash_table_flat.html#f_copy">copy</A> (other: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Re-initialize from </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
            type_identity: <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
        <B>do</B>
            <B>if</B> other /= <B>Current</B> <B>then</B>
                <A HREF="../elks/any_flat.html#f_standard_copy">standard_copy</A> (other)
                <A HREF="../elks/hash_table_flat.html#f_set_content">set_content</A> (other.<A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/any_flat.html#f_twin">twin</A>)
                <A HREF="../elks/hash_table_flat.html#f_set_keys">set_keys</A> (other.<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/any_flat.html#f_twin">twin</A>)
                <A HREF="../elks/hash_table_flat.html#f_set_deleted_marks">set_deleted_marks</A> (other.<A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/any_flat.html#f_twin">twin</A>)
                <A HREF="../elks/hash_table_flat.html#f_set_indexes_map">set_indexes_map</A> (other.<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/any_flat.html#f_twin">twin</A>)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            is_equal: <B>Current</B> ~ other
        <B>end</B></A>

    <A NAME="f_deep_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_clone">deep_clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `deep_twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void: otherwise, new object structure</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> recursively duplicated from the one attached to </FONT>`other'
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (other, <B>Result</B>)
        <B>end</B></A>

    <A NAME="f_deep_copy"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_copy">deep_copy</A> (other: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Effect equivalent to that of:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">		</FONT><A HREF="../elks/hash_table_flat.html#f_copy">copy</A><FONT COLOR="red"> (</FONT>`other'<FONT COLOR="red"> . </FONT><A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A><FONT COLOR="red">)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_copy">copy</A> (other.<A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (<B>Current</B>, other)
        <B>end</B></A>

    <A NAME="f_deep_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object structure recursively duplicated from Current.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_twin_not_void: <B>Result</B> /= <B>Void</B>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (<B>Current</B>, <B>Result</B>)
        <B>end</B></A>

    <A NAME="f_standard_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_clone">standard_clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `standard_twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void; otherwise new object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> field-by-field identical to </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default copying semantics.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_standard_twin">standard_twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            equal: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (<B>Result</B>, other)
        <B>end</B></A>

    <A NAME="f_standard_copy"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_copy">standard_copy</A> (other: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Copy every field of </FONT>`other'<FONT COLOR="red"> onto corresponding field</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
            type_identity: <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            is_standard_equal: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other)
        <B>end</B></A>

    <A NAME="f_standard_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_twin">standard_twin</A>: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object field-by-field identical to </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default copying semantics.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            standard_twin_not_void: <B>Result</B> /= <B>Void</B>
            equal: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (<B>Result</B>, <B>Current</B>)
        <B>end</B></A>

    <A NAME="f_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_twin">twin</A>: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object equal to </FONT>`Current'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><A HREF="../elks/any_flat.html#f_twin">twin</A><FONT COLOR="red"> calls </FONT><A HREF="../elks/hash_table_flat.html#f_copy">copy</A><FONT COLOR="red">; to change copying/twinning semantics, redefine </FONT><A HREF="../elks/hash_table_flat.html#f_copy">copy</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            twin_not_void: <B>Result</B> /= <B>Void</B>
            is_equal: <B>Result</B> ~ <B>Current</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_empty_duplicate"><A HREF="../elks/hash_table_flat.html#f_empty_duplicate">empty_duplicate</A> (n: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create an empty copy of Current that can accommodate </FONT>`n'<FONT COLOR="red"> items</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            n_non_negative: n &gt;= 0
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/hash_table_flat.html#f_make">make</A> (n)
            <B>if</B> <A HREF="../elks/container_flat.html#f_object_comparison">object_comparison</A> <B>then</B>
                <B>Result</B>.<A HREF="../elks/container_flat.html#f_compare_objects">compare_objects</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            empty_duplicate_attached: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Basic operations</FONT>

    <A NAME="f_as_attached"><B>frozen</B> <A HREF="../elks/any_flat.html#f_as_attached">as_attached</A>: <B>attached</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Attached version of Current</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Can be used during transitional period to convert</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> non-void-safe classes to void-safe ones.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <B>Current</B>
        <B>end</B></A>

    <A NAME="f_default"><B>frozen</B> <A HREF="../elks/any_flat.html#f_default">default</A>: <B>detachable</B> <A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of object's type</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_default_pointer"><B>frozen</B> <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>: <A HREF="../elks/pointer_flat.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of type </FONT>`POINTER'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Avoid the need to write </FONT>`p'<FONT COLOR="red">.</FONT><A HREF="../elks/any_flat.html#f_default">default</A><FONT COLOR="red"> for</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> some </FONT>`p'<FONT COLOR="red"> of type </FONT>`POINTER'<FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_default_rescue"><A HREF="../elks/any_flat.html#f_default_rescue">default_rescue</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Process exception for routines with no Rescue clause.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Default: do nothing.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_do_nothing"><B>frozen</B> <A HREF="../elks/any_flat.html#f_do_nothing">do_nothing</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Execute a null action.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Inapplicable</FONT>

    <A NAME="f_bag_put"><A HREF="../elks/table_flat.html#f_bag_put">bag_put</A> (v: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Ensure that structure includes </FONT>`v'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/table_flat.html">TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            extendible: <A HREF="../elks/hash_table_flat.html#f_extendible">Extendible</A>
        <B>do</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            item_inserted: <A HREF="../elks/collection_flat.html#f_is_inserted">is_inserted</A> (v)
        <B>end</B></A>

    <A NAME="f_collection_extend"><A HREF="../elks/hash_table_flat.html#f_collection_extend">collection_extend</A> (v: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Insert a new occurrence of </FONT>`v'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            extendible: <A HREF="../elks/hash_table_flat.html#f_extendible">Extendible</A>
        <B>do</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/collection_flat.html">COLLECTION</A>
            item_inserted: <A HREF="../elks/collection_flat.html#f_is_inserted">is_inserted</A> (v)
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_add_space"><A HREF="../elks/hash_table_flat.html#f_add_space">add_space</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Increase capacity.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_accommodate">accommodate</A> (<A HREF="../elks/hash_table_flat.html#f_count">count</A> + <A HREF="../elks/hash_table_flat.html#f_count">count</A> // 2)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            count_not_changed: <A HREF="../elks/hash_table_flat.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table_flat.html#f_count">count</A>
            breathing_space: <A HREF="../elks/hash_table_flat.html#f_count">count</A> &lt; <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
        <B>end</B></A>

    <A NAME="f_add_translation"><A HREF="../elks/class_name_translations_flat.html#f_add_translation">add_translation</A> (new_name, old_name: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Add a translation entry mapping class </FONT>`old_name'<FONT COLOR="red"> in the</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> storing system to class </FONT>`new_name'<FONT COLOR="red"> in the retrieving system.</FONT>
        <B>local</B>
            n, o: <A HREF="../elks/any_flat.html">ANY</A>
        <B>do</B>
            <B>if</B> new_name /= <B>Void</B> <B>and then</B> old_name /= <B>Void</B> <B>then</B>
                n := new_name.<A HREF="../elks/string_8_flat.html#f_to_c">to_c</A>
                o := old_name.<A HREF="../elks/string_8_flat.html#f_to_c">to_c</A>
                <A HREF="../elks/class_name_translations_flat.html#f_class_translation_put">class_translation_put</A> ($n.<A HREF="../elks/pointer_ref_flat.html#f_item">to_pointer</A>, $o.<A HREF="../elks/pointer_ref_flat.html#f_item">to_pointer</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_computed_default_key"><A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default key</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (For performance reasons, used only in assertions;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> elsewhere, see use of local entity </FONT>`l_default_key'<FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_computed_default_value"><A HREF="../elks/hash_table_flat.html#f_computed_default_value">computed_default_value</A>: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of type G</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (For performance reasons, used only in assertions;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> elsewhere, see use of local entity </FONT>`l_default_value'<FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_conflict_constant"><A HREF="../elks/hash_table_flat.html#f_conflict_constant">Conflict_constant</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 1</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Could not insert an already existing key</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_default_key_value"><A HREF="../elks/hash_table_flat.html#f_default_key_value">default_key_value</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Value associated with the default key, if any</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            has_default: <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_content">content</A> [<A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A> [<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>]]
        <B>end</B></A>

    <A NAME="f_deleted"><A HREF="../elks/hash_table_flat.html#f_deleted">deleted</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is position </FONT>`i'<FONT COLOR="red"> that of a deleted item?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            in_bounds: i &gt;= 0 <B>and</B> i &lt;= <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i) &lt;= <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
        <B>end</B></A>

    <A NAME="f_deleted_position"><A HREF="../elks/hash_table_flat.html#f_deleted_position">deleted_position</A> (a_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Given the position of a deleted item at </FONT>`a_pos'<FONT COLOR="red"> gives the associated position</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in </FONT>`content/keys'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            deleted: <A HREF="../elks/hash_table_flat.html#f_deleted">deleted</A> (a_pos)
        <B>do</B>
            <B>Result</B> := - <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (a_pos) + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
            <B>Result</B> := <B>Result</B>.<A HREF="../elks/comparable_flat.html#f_min">min</A> (<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            deleted_position_non_negative: <B>Result</B> &gt;= 0
            deleted_position_valid: <B>Result</B> &lt;= <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> <B>and</B> <B>Result</B> &lt;= <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_found_constant"><A HREF="../elks/hash_table_flat.html#f_found_constant">Found_constant</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 2</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key found</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_ht_deleted_item"><A HREF="../elks/hash_table_flat.html#f_ht_deleted_item">ht_deleted_item</A>: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A></A>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_ht_deleted_key"><A HREF="../elks/hash_table_flat.html#f_ht_deleted_key">ht_deleted_key</A>: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Store the item and key that will be used to replace an element of the HASH_TABLE</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> that will be removed. If elements being removed are at the end of </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red"> or </FONT><A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> then they are both Void. It is only used when removing an element at a position strictly</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> less than </FONT><A HREF="../elks/hash_table_flat.html#f_count">count</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_ht_deleted_position"><A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = -2</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Marked a deleted position.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_ht_impossible_position"><A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = -1</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position outside the array indices.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_ht_lowest_deleted_position"><A HREF="../elks/hash_table_flat.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Index of the lowest deleted position thus far.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_ht_max_position"><A HREF="../elks/hash_table_flat.html#f_ht_max_position">Ht_max_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 2147483645</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Maximum possible position</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_initial_position"><A HREF="../elks/hash_table_flat.html#f_initial_position">initial_position</A> (hash_value: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initial position for an item of hash code </FONT>`hash_value'
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (hash_value \\ <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>)
        <B>end</B></A>

    <A NAME="f_inserted_constant"><A HREF="../elks/hash_table_flat.html#f_inserted_constant">Inserted_constant</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 4</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Insertion successful</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_internal_search"><A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A> (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Search for item of key </FONT>`key'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If successful, set </FONT><A HREF="../elks/hash_table_flat.html#f_position">position</A><FONT COLOR="red"> to index</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of item with this key (the same index as the key's index).</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If not, set </FONT><A HREF="../elks/hash_table_flat.html#f_position">position</A><FONT COLOR="red"> to possible position for insertion,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> and set status to </FONT><A HREF="../elks/hash_table_flat.html#f_found">found</A><FONT COLOR="red"> or </FONT><A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
            l_key: <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                    <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_found_constant">Found_constant</A>
                <B>else</B>
                    <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_not_found_constant">Not_found_constant</A>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table_flat.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                    <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_not_found_constant">Not_found_constant</A>
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special_flat.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table_flat.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_found_constant">Found_constant</A>
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special_flat.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := l_item_pos
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A> := l_first_deleted_position
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            found_or_not_found: <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
            deleted_item_at_deleted_position: (<A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A> /= <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>) <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_deleted">deleted</A> (<A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A>))
            default_iff_at_capacity: (<A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> = <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>) = (key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>)
        <B>end</B></A>

    <A NAME="f_is_off_position"><A HREF="../elks/hash_table_flat.html#f_is_off_position">is_off_position</A> (pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`pos'<FONT COLOR="red"> a cursor position outside the authorized range?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := pos &lt; 0 <B>or</B> pos &gt;= <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_key_at"><A HREF="../elks/hash_table_flat.html#f_key_at">key_at</A> (n: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key at position </FONT>`n'
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_valid_index">valid_index</A> (n) <B>then</B>
                <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (n)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_minimum_capacity"><A HREF="../elks/hash_table_flat.html#f_minimum_capacity">Minimum_capacity</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 2</A>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_not_found_constant"><A HREF="../elks/hash_table_flat.html#f_not_found_constant">Not_found_constant</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key not found</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_occupied"><A HREF="../elks/hash_table_flat.html#f_occupied">occupied</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is position </FONT>`i'<FONT COLOR="red"> occupied by a non-default key and a value?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            in_bounds: <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_valid_index">valid_index</A> (i)
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>then</B>
                <B>Result</B> := i /= <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>) <B>and then</B> <B>not</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i)
            <B>else</B>
                <B>Result</B> := <B>not</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (i)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_position_increment"><A HREF="../elks/hash_table_flat.html#f_position_increment">position_increment</A> (hash_value: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Distance between successive positions for hash code</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`hash_value'<FONT COLOR="red"> (computed for no cycle: </FONT><A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A><FONT COLOR="red"> is prime)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := 1 + hash_value \\ (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> - 1)
        <B>end</B></A>

    <A NAME="f_removed_constant"><A HREF="../elks/hash_table_flat.html#f_removed_constant">Removed_constant</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 16</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove successful</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_replaced_constant"><A HREF="../elks/hash_table_flat.html#f_replaced_constant">Replaced_constant</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Replaced value</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_search_for_insertion"><A HREF="../elks/hash_table_flat.html#f_search_for_insertion">search_for_insertion</A> (key: <A HREF="../elks/string_8_flat.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assuming there is no item of key </FONT>`key'<FONT COLOR="red">, compute</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><A HREF="../elks/hash_table_flat.html#f_position">position</A><FONT COLOR="red"> at which to insert such an item.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            not_present: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has">has</A> (key)
        <B>local</B>
            l_default_key: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>check</B>
                    <B>not</B> <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table_flat.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special_flat.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
                <A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> := l_item_pos
            <B>end</B>
            <A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A> := l_first_deleted_position
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            deleted_item_at_deleted_position: (<A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A> /= <A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A>) <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_deleted">deleted</A> (<A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A>))
            default_iff_at_capacity: (<A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A> = <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>) = (key = <A HREF="../elks/hash_table_flat.html#f_computed_default_key">computed_default_key</A>)
        <B>end</B></A>

    <A NAME="f_set_conflict"><A HREF="../elks/hash_table_flat.html#f_set_conflict">set_conflict</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to conflict.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_conflict_constant">Conflict_constant</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            conflict: <A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A>
        <B>end</B></A>

    <A NAME="f_set_content"><A HREF="../elks/hash_table_flat.html#f_set_content">set_content</A> (c: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_content">content</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT>`c'<FONT COLOR="red"> to </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            c_attached: c /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_content">content</A> := c
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            content_set: <A HREF="../elks/hash_table_flat.html#f_content">content</A> = c
        <B>end</B></A>

    <A NAME="f_set_deleted_marks"><A HREF="../elks/hash_table_flat.html#f_set_deleted_marks">set_deleted_marks</A> (d: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT>`c'<FONT COLOR="red"> to </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            d_attached: d /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A> := d
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            deleted_marks_set: <A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A> = d
        <B>end</B></A>

    <A NAME="f_set_found"><A HREF="../elks/hash_table_flat.html#f_set_found">set_found</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to found.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_found_constant">Found_constant</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            found: <A HREF="../elks/hash_table_flat.html#f_found">found</A>
        <B>end</B></A>

    <A NAME="f_set_indexes_map"><A HREF="../elks/hash_table_flat.html#f_set_indexes_map">set_indexes_map</A> (v: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT>`v'<FONT COLOR="red"> to </FONT><A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A> := v
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            indexes_map_set: <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A> = v
        <B>end</B></A>

    <A NAME="f_set_inserted"><A HREF="../elks/hash_table_flat.html#f_set_inserted">set_inserted</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to inserted.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_inserted_constant">Inserted_constant</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            inserted: <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A>
        <B>end</B></A>

    <A NAME="f_set_keys"><A HREF="../elks/hash_table_flat.html#f_set_keys">set_keys</A> (c: <B>like</B> <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT>`c'<FONT COLOR="red"> to </FONT><A HREF="../elks/hash_table_flat.html#f_keys">keys</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            c_attached: c /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_keys">keys</A> := c
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            keys_set: <A HREF="../elks/hash_table_flat.html#f_keys">keys</A> = c
        <B>end</B></A>

    <A NAME="f_set_no_status"><A HREF="../elks/hash_table_flat.html#f_set_no_status">set_no_status</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to normal.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := 0
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            default_status: <B>not</B> <A HREF="../elks/hash_table_flat.html#f_special_status">special_status</A>
        <B>end</B></A>

    <A NAME="f_set_not_found"><A HREF="../elks/hash_table_flat.html#f_set_not_found">set_not_found</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to not found.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_not_found_constant">Not_found_constant</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            not_found: <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>
        <B>end</B></A>

    <A NAME="f_set_removed"><A HREF="../elks/hash_table_flat.html#f_set_removed">set_removed</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to removed.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_removed_constant">Removed_constant</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            removed: <A HREF="../elks/hash_table_flat.html#f_removed">removed</A>
        <B>end</B></A>

    <A NAME="f_set_replaced"><A HREF="../elks/hash_table_flat.html#f_set_replaced">set_replaced</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to replaced.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table_flat.html#f_control">control</A> := <A HREF="../elks/hash_table_flat.html#f_replaced_constant">Replaced_constant</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            replaced: <A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A>
        <B>end</B></A>

    <A NAME="f_special_status"><A HREF="../elks/hash_table_flat.html#f_special_status">special_status</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Has status been set to some non-default value?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_control">control</A> &gt; 0)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            <B>Result</B> = (<A HREF="../elks/hash_table_flat.html#f_control">control</A> &gt; 0)
        <B>end</B></A>

    <A NAME="f_truly_occupied"><A HREF="../elks/hash_table_flat.html#f_truly_occupied">truly_occupied</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is position </FONT>`i'<FONT COLOR="red"> occupied by a key and a value?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> i &gt;= 0 <B>and</B> i &lt; <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> <B>then</B>
                <B>Result</B> := (<A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A> <B>and</B> i = <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>)) <B>or else</B> <A HREF="../elks/hash_table_flat.html#f_occupied">occupied</A> (i)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            normal_key: (i &gt;= 0 <B>and</B> i &lt; <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> <B>and</B> i /= <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>)) <B>implies</B> (<A HREF="../elks/hash_table_flat.html#f_occupied">occupied</A> (i) <B>implies</B> <B>Result</B>)
            default_key: (i = <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>)) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Correction</FONT>

    <A NAME="f_mismatch_information"><A HREF="../elks/mismatch_corrector_flat.html#f_mismatch_information">Mismatch_information</A>: <A HREF="../elks/mismatch_information_flat.html">MISMATCH_INFORMATION</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Original attribute values of mismatched object</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/mismatch_corrector_flat.html">MISMATCH_CORRECTOR</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Externals</FONT>

    <A NAME="f_class_translation_clear"><A HREF="../elks/class_name_translations_flat.html#f_class_translation_clear">class_translation_clear</A>
        <B>external</B>
            "C use %"eif_retrieve.h%""
        <B>end</B></A>

    <A NAME="f_class_translation_count"><A HREF="../elks/class_name_translations_flat.html#f_class_translation_count">class_translation_count</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>external</B>
            "C use %"eif_retrieve.h%""
        <B>end</B></A>

    <A NAME="f_class_translation_new"><A HREF="../elks/class_name_translations_flat.html#f_class_translation_new">class_translation_new</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/pointer_flat.html">POINTER</A>
        <B>external</B>
            "C use %"eif_retrieve.h%""
        <B>end</B></A>

    <A NAME="f_class_translation_old"><A HREF="../elks/class_name_translations_flat.html#f_class_translation_old">class_translation_old</A> (i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/pointer_flat.html">POINTER</A>
        <B>external</B>
            "C use %"eif_retrieve.h%""
        <B>end</B></A>

    <A NAME="f_class_translation_put"><A HREF="../elks/class_name_translations_flat.html#f_class_translation_put">class_translation_put</A> (new_name, old_name: <A HREF="../elks/pointer_flat.html">POINTER</A>)
        <B>external</B>
            "C use %"eif_retrieve.h%""
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>, <A HREF="../elks/hash_table_iteration_cursor_flat.html">HASH_TABLE_ITERATION_CURSOR</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: content attributes and preservation</FONT>

    <A NAME="f_content"><A HREF="../elks/hash_table_flat.html#f_content">content</A>: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Array of contents</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_keys"><A HREF="../elks/hash_table_flat.html#f_keys">keys</A>: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/string_8_flat.html">STRING_8</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Array of keys</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
    
<B>feature</B> {<A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: content attributes and preservation</FONT>

    <A NAME="f_deleted_marks"><A HREF="../elks/hash_table_flat.html#f_deleted_marks">deleted_marks</A>: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/boolean_flat.html">BOOLEAN</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Indexes of deleted positions in </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red"> and </FONT><A HREF="../elks/hash_table_flat.html#f_keys">keys</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_has_default"><A HREF="../elks/hash_table_flat.html#f_has_default">has_default</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is the default key present?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_indexes_map"><A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Indexes of items in </FONT><A HREF="../elks/hash_table_flat.html#f_content">content</A><FONT COLOR="red">, and </FONT><A HREF="../elks/hash_table_flat.html#f_keys">keys</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If item is not present, then it has </FONT><A HREF="../elks/hash_table_flat.html#f_ht_impossible_position">Ht_impossible_position</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If item is deleted, then it has </FONT><A HREF="../elks/hash_table_flat.html#f_ht_deleted_position">Ht_deleted_position</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_item_position"><A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position in </FONT><A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A><FONT COLOR="red"> for item at position </FONT><A HREF="../elks/hash_table_flat.html#f_position">position</A><FONT COLOR="red">. Set by </FONT><A HREF="../elks/hash_table_flat.html#f_internal_search">internal_search</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
    
<B>feature</B> {<A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: search attributes</FONT>

    <A NAME="f_control"><A HREF="../elks/hash_table_flat.html#f_control">control</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Control code set by operations that may produce</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> several possible conditions.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_deleted_item_position"><A HREF="../elks/hash_table_flat.html#f_deleted_item_position">deleted_item_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Place where a deleted element was found during a search</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_iteration_position"><A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cursor for iteration primitives</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>

    <A NAME="f_position"><A HREF="../elks/hash_table_flat.html#f_position">position</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hash table cursor, updated after each operation:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> put, remove, has, replace, force, change_key...</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special_flat.html#f_item">item</A> (<A HREF="../elks/hash_table_flat.html#f_item_position">item_position</A>)
        <B>end</B></A>

    <A NAME="f_soon_full"><A HREF="../elks/hash_table_flat.html#f_soon_full">soon_full</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is table close to being filled to current capacity?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> = <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_capacity">capacity</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
            <B>Result</B> = (<A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> = <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_capacity">capacity</A>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Output</FONT>

    <A NAME="f_io"><A HREF="../elks/any_flat.html#f_io">Io</A>: <A HREF="../elks/std_files_flat.html">STD_FILES</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Handle to standard file setup</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
            <B>Result</B>.<A HREF="../elks/std_files_flat.html#f_set_output_default">set_output_default</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            io_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_out"><A HREF="../elks/class_name_translations_flat.html#f_out">out</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Printable representation of translations</FONT>
        <B>local</B>
            k: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            i: <B>detachable</B> <A HREF="../elks/string_8_flat.html">STRING_8</A>
        <B>do</B>
            <B>from</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_8_flat.html#f_make">make</A> (25 + <A HREF="../elks/hash_table_flat.html#f_count">count</A> * 40)
                <B>Result</B>.<A HREF="../elks/string_8_flat.html#f_append">append</A> ("Class name translations:%N")
                <A HREF="../elks/hash_table_flat.html#f_start">start</A>
            <B>until</B>
                <A HREF="../elks/hash_table_flat.html#f_after">after</A>
            <B>loop</B>
                k := <A HREF="../elks/hash_table_flat.html#f_key_for_iteration">key_for_iteration</A>
                <B>if</B> k /= <B>Void</B> <B>then</B>
                    <B>Result</B>.<A HREF="../elks/string_8_flat.html#f_append">append</A> (k)
                <B>end</B>
                <B>Result</B>.<A HREF="../elks/string_8_flat.html#f_append">append</A> (" -&gt; ")
                i := <A HREF="../elks/hash_table_flat.html#f_item_for_iteration">item_for_iteration</A>
                <B>if</B> i /= <B>Void</B> <B>then</B>
                    <B>Result</B>.<A HREF="../elks/string_8_flat.html#f_append">append</A> (i)
                <B>end</B>
                <B>Result</B>.<A HREF="../elks/string_8_flat.html#f_append_character">append_character</A> ('%N')
                <A HREF="../elks/hash_table_flat.html#f_forth">forth</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            out_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_print"><A HREF="../elks/any_flat.html#f_print">print</A> (o: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Write terse external representation of </FONT>`o'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> on standard output.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> o /= <B>Void</B> <B>then</B>
                <A HREF="../elks/any_flat.html#f_io">Io</A>.<A HREF="../elks/std_files_flat.html#f_put_string">put_string</A> (o.<A HREF="../elks/any_flat.html#f_out">out</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_tagged_out"><B>frozen</B> <A HREF="../elks/any_flat.html#f_tagged_out">tagged_out</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New string containing terse printable representation</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            tagged_out_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Platform</FONT>

    <A NAME="f_operating_environment"><A HREF="../elks/any_flat.html#f_operating_environment">Operating_environment</A>: <A HREF="../elks/operating_environment_flat.html">OPERATING_ENVIRONMENT</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Objects available from the operating system</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            operating_environment_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Retrieval</FONT>

    <A NAME="f_internal_correct_mismatch"><B>frozen</B> <A HREF="../elks/any_flat.html#f_internal_correct_mismatch">internal_correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Called from runtime to perform a proper dynamic dispatch on </FONT><A HREF="../elks/hash_table_flat.html#f_correct_mismatch">correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> from MISMATCH_CORRECTOR.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_msg: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_exc: <A HREF="../elks/exceptions_flat.html">EXCEPTIONS</A>
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/mismatch_corrector_flat.html">MISMATCH_CORRECTOR</A>} <B>Current</B> <B>as</B> l_corrector <B>then</B>
                l_corrector.<A HREF="../elks/mismatch_corrector_flat.html#f_correct_mismatch">correct_mismatch</A>
            <B>else</B>
                <B>create</B> l_msg.<A HREF="../elks/readable_string_8_flat.html#f_make_from_string">make_from_string</A> ("Mismatch: ")
                <B>create</B> l_exc
                l_msg.<A HREF="../elks/string_8_flat.html#f_append">append</A> (<A HREF="../elks/any_flat.html#f_generating_type">generating_type</A>.<A HREF="../elks/type_flat.html#f_name">name</A>)
                l_exc.<A HREF="../elks/exceptions_flat.html#f_raise_retrieval_exception">raise_retrieval_exception</A> (l_msg)
            <B>end</B>
        <B>end</B></A>
    
<B>invariant</B>
        <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/hash_table_flat.html">HASH_TABLE</A>
    keys_not_void: <A HREF="../elks/hash_table_flat.html#f_keys">keys</A> /= <B>Void</B>
    content_not_void: <A HREF="../elks/hash_table_flat.html#f_content">content</A> /= <B>Void</B>
    keys_enough_capacity: <A HREF="../elks/hash_table_flat.html#f_keys">keys</A>.<A HREF="../elks/special_flat.html#f_count">count</A> &lt;= <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> + 1
    content_enough_capacity: <A HREF="../elks/hash_table_flat.html#f_content">content</A>.<A HREF="../elks/special_flat.html#f_count">count</A> &lt;= <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A> + 1
    valid_iteration_position: <A HREF="../elks/hash_table_flat.html#f_off">off</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_truly_occupied">truly_occupied</A> (<A HREF="../elks/hash_table_flat.html#f_iteration_position">iteration_position</A>)
    control_non_negative: <A HREF="../elks/hash_table_flat.html#f_control">control</A> &gt;= 0
    special_status: <A HREF="../elks/hash_table_flat.html#f_special_status">special_status</A> = (<A HREF="../elks/hash_table_flat.html#f_conflict">conflict</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_inserted">inserted</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_removed">removed</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table_flat.html#f_not_found">not_found</A>)
    count_big_enough: 0 &lt;= <A HREF="../elks/hash_table_flat.html#f_count">count</A>
    count_small_enough: <A HREF="../elks/hash_table_flat.html#f_count">count</A> &lt;= <A HREF="../elks/hash_table_flat.html#f_capacity">capacity</A>
    slot_count_big_enough: 0 &lt;= <A HREF="../elks/hash_table_flat.html#f_count">count</A>

        <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/finite_flat.html">FINITE</A>
    empty_definition: <A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A> = (<A HREF="../elks/hash_table_flat.html#f_count">count</A> = 0)

        <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
    reflexive_equality: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (<B>Current</B>)
    reflexive_conformance: <A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (<B>Current</B>)

<B>note</B>
    copyright: "Copyright (c) 1984-2012, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/class_name_translations_flat.html">CLASS_NAME_TRANSLATIONS</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="class_name_translations_chart.html">Chart</A></TD><TD><A HREF="class_name_translations_links.html">Relations</A></TD><TD><A HREF="class_name_translations.html">Text</A></TD><TD>Flat</TD><TD><A HREF="class_name_translations_short.html">Contracts</A></TD><TD><A HREF="class_name_translations_flatshort.html">Flat contracts</A></TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

