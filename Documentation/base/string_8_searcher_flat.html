<HTML><HEAD>
<meta name="description" content="Helper to perform efficient search of a string in another one. Note: The algorithm used is the one described in Communications of the ACM, Tvolume 33, number 8, August 1990, by Daniel M. Sunday. The fuzzy Tversion was presented by Peter R. Sibbald in Communications of the TACM, volume 35, number 4, April 1992 (Technical Correspondance)."/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="legal" content="See notice at end of class."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2012, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>string_8_searcher Flat</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="string_8_searcher_chart.html">Chart</A></TD><TD><A HREF="string_8_searcher_links.html">Relations</A></TD><TD><A HREF="string_8_searcher.html">Text</A></TD><TD>Flat</TD><TD><A HREF="string_8_searcher_short.html">Contracts</A></TD><TD><A HREF="string_8_searcher_flatshort.html">Flat contracts</A></TD></TR></TABLE><B>note</B>
    description: "[
        Helper to perform efficient search of a string in another one.
        Note: The algorithm used is the one described in Communications of the ACM,
        	volume 33, number 8, August 1990, by Daniel M. Sunday. The fuzzy
        	version was presented by Peter R. Sibbald in Communications of the
        	ACM, volume 35, number 4, April 1992 (Technical Correspondance).
    ]"
    library: "Free implementation of ELKS library"
    status: "See notice at end of class."
    legal: "See notice at end of class."
    date: "$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $"
    revision: "$Revision: 91981 $"

<B>frozen</B> <B>class</B> 
    <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>

<B>create</B> 
    <A HREF="../elks/string_searcher_flat.html#f_make">make</A>

<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_default_create"><A HREF="../elks/any_flat.html#f_default_create">default_create</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Process instances of classes with no creation clause.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Default: do nothing.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_make"><A HREF="../elks/string_searcher_flat.html#f_make">make</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>create</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>.<A HREF="../elks/special_flat.html#f_make_empty">make_empty</A> (<A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A> + 1)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_initialize_deltas"><A HREF="../elks/string_searcher_flat.html#f_initialize_deltas">initialize_deltas</A> (a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize </FONT><A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A><FONT COLOR="red"> with </FONT>`a_pattern'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Optimized for the top </FONT><A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A><FONT COLOR="red"> characters only.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_pattern_not_void: a_pattern /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/string_searcher_flat.html#f_internal_initialize_deltas">internal_initialize_deltas</A> (a_pattern, a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>, <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_generating_type"><A HREF="../elks/any_flat.html#f_generating_type">generating_type</A>: <A HREF="../elks/type_flat.html">TYPE</A> [<B>detachable</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type of current object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (type of which it is a direct instance)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := {<B>detachable</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>}
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            generating_type_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_generator"><A HREF="../elks/any_flat.html#f_generator">generator</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Name of current object's generating class</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (base class of the type of which it is a direct instance)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            generator_not_void: <B>Result</B> /= <B>Void</B>
            generator_not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_max_code_point_value"><A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A> = 255</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Maximum character value for which we optimize the lookup of a pattern.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If any item's code of the searched string is above that limit, search will</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> not be as efficient.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> For STRING_8, it is limited to the number of characters in the extended ASCII character set.</FONT>

    <A NAME="f_string_type"><A HREF="../elks/string_8_searcher_flat.html#f_string_type">string_type</A>: <A HREF="../elks/readable_string_8_flat.html">READABLE_STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type of strings </FONT>`Current'<FONT COLOR="red"> manipulate to perform searches.</FONT>
        <B>do</B>
            <B>Result</B> := ""
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            for_typing_only: <B>False</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Comparison</FONT>

    <A NAME="f_deep_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> or attached to isomorphic object structures?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            shallow_implies_deep: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (a, b) <B>implies</B> <B>Result</B>
            both_or_none_void: (a = <B>Void</B>) <B>implies</B> (<B>Result</B> = (b = <B>Void</B>))
            same_type: (<B>Result</B> <B>and</B> (a /= <B>Void</B>)) <B>implies</B> (b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (b))
            symmetric: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (b, a)
        <B>end</B></A>

    <A NAME="f_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_equal">equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void or attached</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to objects considered equal?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (a = <B>Void</B> <B>and</B> b = <B>Void</B>) <B>or else</B> ((a /= <B>Void</B> <B>and</B> b /= <B>Void</B>) <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (b))
        <B>end</B></A>

    <A NAME="f_is_deep_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (other: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`Current'<FONT COLOR="red"> and </FONT>`other'<FONT COLOR="red"> attached to isomorphic object structures?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            shallow_implies_deep: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other) <B>implies</B> <B>Result</B>
            same_type: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
            symmetric: <B>Result</B> <B>implies</B> other.<A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (<B>Current</B>)
        <B>end</B></A>

    <A NAME="f_is_equal"><A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (other: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`other'<FONT COLOR="red"> attached to an object considered</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> equal to current object?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            symmetric: <B>Result</B> <B>implies</B> other ~ <B>Current</B>
            consistent: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other) <B>implies</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_standard_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void or attached to</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> field-by-field identical objects of the same type?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default object comparison criterion.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (a = <B>Void</B> <B>and</B> b = <B>Void</B>) <B>or else</B> ((a /= <B>Void</B> <B>and</B> b /= <B>Void</B>) <B>and then</B> a.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (b))
        <B>end</B></A>

    <A NAME="f_standard_is_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`other'<FONT COLOR="red"> attached to an object of the same type</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> as current object, and field-by-field identical to it?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            same_type: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
            symmetric: <B>Result</B> <B>implies</B> other.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (<B>Current</B>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_conforms_to"><A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (other: <A HREF="../elks/any_flat.html">ANY</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does type of current object conform to type</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of </FONT>`other'<FONT COLOR="red"> (as per Eiffel: The Language, chapter 13)?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>end</B></A>

    <A NAME="f_same_type"><A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other: <A HREF="../elks/any_flat.html">ANY</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is type of current object identical to type of </FONT>`other'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (<A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (other) <B>and</B> other.<A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (<B>Current</B>))
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_clone">clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void; otherwise new object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> equal to </FONT>`other'
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> For non-void </FONT>`other'<FONT COLOR="red">, </FONT><A HREF="../elks/any_flat.html#f_clone">clone</A><FONT COLOR="red"> calls </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to change copying/cloning semantics, redefine </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_twin">twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            equal: <B>Result</B> ~ other
        <B>end</B></A>

    <A NAME="f_copy"><A HREF="../elks/any_flat.html#f_copy">copy</A> (other: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Update current object using fields of object attached</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to </FONT>`other'<FONT COLOR="red">, so as to yield equal objects.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
            type_identity: <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            is_equal: <B>Current</B> ~ other
        <B>end</B></A>

    <A NAME="f_deep_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_clone">deep_clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `deep_twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void: otherwise, new object structure</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> recursively duplicated from the one attached to </FONT>`other'
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (other, <B>Result</B>)
        <B>end</B></A>

    <A NAME="f_deep_copy"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_copy">deep_copy</A> (other: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Effect equivalent to that of:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">		</FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red"> (</FONT>`other'<FONT COLOR="red"> . </FONT><A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A><FONT COLOR="red">)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/any_flat.html#f_copy">copy</A> (other.<A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (<B>Current</B>, other)
        <B>end</B></A>

    <A NAME="f_deep_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object structure recursively duplicated from Current.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_twin_not_void: <B>Result</B> /= <B>Void</B>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (<B>Current</B>, <B>Result</B>)
        <B>end</B></A>

    <A NAME="f_standard_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_clone">standard_clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `standard_twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void; otherwise new object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> field-by-field identical to </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default copying semantics.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_standard_twin">standard_twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            equal: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (<B>Result</B>, other)
        <B>end</B></A>

    <A NAME="f_standard_copy"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_copy">standard_copy</A> (other: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Copy every field of </FONT>`other'<FONT COLOR="red"> onto corresponding field</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
            type_identity: <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            is_standard_equal: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other)
        <B>end</B></A>

    <A NAME="f_standard_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_twin">standard_twin</A>: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object field-by-field identical to </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default copying semantics.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            standard_twin_not_void: <B>Result</B> /= <B>Void</B>
            equal: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (<B>Result</B>, <B>Current</B>)
        <B>end</B></A>

    <A NAME="f_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_twin">twin</A>: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object equal to </FONT>`Current'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><A HREF="../elks/any_flat.html#f_twin">twin</A><FONT COLOR="red"> calls </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">; to change copying/twinning semantics, redefine </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            twin_not_void: <B>Result</B> /= <B>Void</B>
            is_equal: <B>Result</B> ~ <B>Current</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Basic operations</FONT>

    <A NAME="f_as_attached"><B>frozen</B> <A HREF="../elks/any_flat.html#f_as_attached">as_attached</A>: <B>attached</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Attached version of Current</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Can be used during transitional period to convert</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> non-void-safe classes to void-safe ones.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <B>Current</B>
        <B>end</B></A>

    <A NAME="f_default"><B>frozen</B> <A HREF="../elks/any_flat.html#f_default">default</A>: <B>detachable</B> <A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of object's type</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_default_pointer"><B>frozen</B> <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>: <A HREF="../elks/pointer_flat.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of type </FONT>`POINTER'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Avoid the need to write </FONT>`p'<FONT COLOR="red">.</FONT><A HREF="../elks/any_flat.html#f_default">default</A><FONT COLOR="red"> for</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> some </FONT>`p'<FONT COLOR="red"> of type </FONT>`POINTER'<FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_default_rescue"><A HREF="../elks/any_flat.html#f_default_rescue">default_rescue</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Process exception for routines with no Rescue clause.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Default: do nothing.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_do_nothing"><B>frozen</B> <A HREF="../elks/any_flat.html#f_do_nothing">do_nothing</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Execute a null action.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_initialize_fuzzy_deltas"><A HREF="../elks/string_searcher_flat.html#f_initialize_fuzzy_deltas">initialize_fuzzy_deltas</A> (a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; fuzzy: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Compile </FONT>`a_pattern'<FONT COLOR="red"> by computing the delta shift tables from a pattern</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> string. This has to be done before searching occurs. The first delta</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> table is computed with the full pattern, the second one is computed with</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> the rightmost character removed, and so on. A total of (fuzzy + 1) tables</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> are computed and stored in </FONT><A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            fuzzy_positive: fuzzy &gt; 0
        <B>local</B>
            l_deltas: <B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>
            l_deltas_array: <A HREF="../elks/special_flat.html">SPECIAL</A> [<B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>]
            i, l_fuzzy: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_pattern_count: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>from</B>
                l_pattern_count := a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
                l_fuzzy := fuzzy + 1
                <B>create</B> l_deltas_array.<A HREF="../elks/special_flat.html#f_make_empty">make_empty</A> (l_fuzzy)
            <B>until</B>
                i = l_fuzzy
            <B>loop</B>
                <B>create</B> l_deltas.<A HREF="../elks/special_flat.html#f_make_empty">make_empty</A> (<A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A> + 1)
                l_deltas_array.<A HREF="../elks/special_flat.html#f_extend">extend</A> (l_deltas)
                <A HREF="../elks/string_searcher_flat.html#f_internal_initialize_deltas">internal_initialize_deltas</A> (a_pattern, l_pattern_count - i, l_deltas)
                i := i + 1
            <B>end</B>
            <A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A> := l_deltas_array
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            deltas_array_not_void: <A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A> /= <B>Void</B>
            deltas_array_count_set: <B>attached</B> {<A HREF="../elks/special_flat.html">SPECIAL</A> [<B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>]} <A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A> <B>as</B> delta <B>and then</B> delta.<A HREF="../elks/special_flat.html#f_count">count</A> = fuzzy + 1
        <B>end</B></A>

    <A NAME="f_internal_initialize_deltas"><A HREF="../elks/string_searcher_flat.html#f_internal_initialize_deltas">internal_initialize_deltas</A> (a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; a_pattern_count: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>; a_deltas: <B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize </FONT>`a_deltas'<FONT COLOR="red"> with </FONT>`a_pattern'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Optimized for the top </FONT><A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A><FONT COLOR="red"> characters only.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_count_not_negative: a_pattern_count &gt;= 0
            a_pattern_count_valid: a_pattern_count &lt;= a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
            a_deltas_not_void: a_deltas /= <B>Void</B>
            a_deltas_valid: a_deltas.<A HREF="../elks/special_flat.html#f_capacity">capacity</A> = <A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A> + 1
        <B>local</B>
            i, l_char_code: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            a_deltas.<A HREF="../elks/special_flat.html#f_fill_with">fill_with</A> (a_pattern_count + 1, 0, <A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A>)
            <B>from</B>
                i := 0
            <B>until</B>
                i = a_pattern_count
            <B>loop</B>
                l_char_code := a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_code">code</A> (i + 1).<A HREF="../elks/natural_32_ref_flat.html#f_to_integer_32">to_integer_32</A>
                <B>if</B> l_char_code &lt;= <A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A> <B>then</B>
                    a_deltas.<A HREF="../elks/special_flat.html#f_put">put</A> (a_pattern_count - i, l_char_code)
                <B>end</B>
                i := i + 1
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: Access</FONT>

    <A NAME="f_deltas"><A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Record shifting deltas.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>

    <A NAME="f_deltas_array"><A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A>: <B>detachable</B> <A HREF="../elks/special_flat.html">SPECIAL</A> [<B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Record shifting deltas for fuzzy search.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Output</FONT>

    <A NAME="f_io"><A HREF="../elks/any_flat.html#f_io">Io</A>: <A HREF="../elks/std_files_flat.html">STD_FILES</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Handle to standard file setup</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
            <B>Result</B>.<A HREF="../elks/std_files_flat.html#f_set_output_default">set_output_default</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            io_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_out"><A HREF="../elks/any_flat.html#f_out">out</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New string containing terse printable representation</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/any_flat.html#f_tagged_out">tagged_out</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            out_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_print"><A HREF="../elks/any_flat.html#f_print">print</A> (o: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Write terse external representation of </FONT>`o'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> on standard output.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> o /= <B>Void</B> <B>then</B>
                <A HREF="../elks/any_flat.html#f_io">Io</A>.<A HREF="../elks/std_files_flat.html#f_put_string">put_string</A> (o.<A HREF="../elks/any_flat.html#f_out">out</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_tagged_out"><B>frozen</B> <A HREF="../elks/any_flat.html#f_tagged_out">tagged_out</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New string containing terse printable representation</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            tagged_out_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Platform</FONT>

    <A NAME="f_operating_environment"><A HREF="../elks/any_flat.html#f_operating_environment">Operating_environment</A>: <A HREF="../elks/operating_environment_flat.html">OPERATING_ENVIRONMENT</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Objects available from the operating system</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            operating_environment_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Retrieval</FONT>

    <A NAME="f_internal_correct_mismatch"><B>frozen</B> <A HREF="../elks/any_flat.html#f_internal_correct_mismatch">internal_correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Called from runtime to perform a proper dynamic dispatch on </FONT>`correct_mismatch'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> from MISMATCH_CORRECTOR.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_msg: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_exc: <A HREF="../elks/exceptions_flat.html">EXCEPTIONS</A>
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/mismatch_corrector_flat.html">MISMATCH_CORRECTOR</A>} <B>Current</B> <B>as</B> l_corrector <B>then</B>
                l_corrector.<A HREF="../elks/mismatch_corrector_flat.html#f_correct_mismatch">correct_mismatch</A>
            <B>else</B>
                <B>create</B> l_msg.<A HREF="../elks/readable_string_8_flat.html#f_make_from_string">make_from_string</A> ("Mismatch: ")
                <B>create</B> l_exc
                l_msg.<A HREF="../elks/string_8_flat.html#f_append">append</A> (<A HREF="../elks/any_flat.html#f_generating_type">generating_type</A>.<A HREF="../elks/type_flat.html#f_name">name</A>)
                l_exc.<A HREF="../elks/exceptions_flat.html#f_raise_retrieval_exception">raise_retrieval_exception</A> (l_msg)
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Search</FONT>

    <A NAME="f_fuzzy_index"><A HREF="../elks/string_8_searcher_flat.html#f_fuzzy_index">fuzzy_index</A> (a_string: <B>like</B> <A HREF="../elks/string_8_searcher_flat.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos, fuzzy: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of first occurrence of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'<FONT COLOR="red"> in</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`a_string'<FONT COLOR="red"> with 0..</FONT>`fuzzy'<FONT COLOR="red"> mismatches between </FONT>`a_string'<FONT COLOR="red"> and </FONT>`a_pattern'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 0 if there are no fuzzy matches.</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_not_empty: <B>not</B> a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_is_empty">is_empty</A>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_8_flat.html#f_count">count</A>
            fuzzy_non_negative: fuzzy &gt;= 0
            acceptable_fuzzy: fuzzy &lt;= a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
        <B>local</B>
            i, j, l_min_offset, l_end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_pattern_count, l_nb_mismatched: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_matched: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            l_char_code: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_deltas_array: <B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A>
            l_area: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/character_8_flat.html">CHARACTER_8</A>]
            l_area_lower: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> fuzzy = a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A> <B>then</B>
                <B>Result</B> := start_pos
            <B>else</B>
                <B>if</B> fuzzy = 0 <B>then</B>
                    <B>Result</B> := <A HREF="../elks/string_searcher_flat.html#f_substring_index">substring_index</A> (a_string, a_pattern, start_pos, end_pos)
                <B>else</B>
                    <A HREF="../elks/string_searcher_flat.html#f_initialize_fuzzy_deltas">initialize_fuzzy_deltas</A> (a_pattern, fuzzy)
                    l_deltas_array := <A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A>
                    <B>if</B> l_deltas_array /= <B>Void</B> <B>then</B>
                        <B>from</B>
                            l_pattern_count := a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
                            l_area := a_string.<A HREF="../elks/readable_string_8_flat.html#f_area">area</A>
                            l_area_lower := a_string.<A HREF="../elks/readable_string_8_flat.html#f_area_lower">area_lower</A>
                            i := start_pos + l_area_lower
                            l_end_pos := end_pos + 1 + l_area_lower
                        <B>until</B>
                            i + l_pattern_count &gt; l_end_pos
                        <B>loop</B>
                            <B>from</B>
                                j := 0
                                l_nb_mismatched := 0
                                l_matched := <B>True</B>
                            <B>until</B>
                                j = l_pattern_count
                            <B>loop</B>
                                <B>if</B> l_area.<A HREF="../elks/special_flat.html#f_item">item</A> (i + j - 1).<A HREF="../elks/character_8_ref_flat.html#f_natural_32_code">natural_32_code</A> /= a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_code">code</A> (j + 1) <B>then</B>
                                    l_nb_mismatched := l_nb_mismatched + 1
                                    <B>if</B> l_nb_mismatched &gt; fuzzy <B>then</B>
                                        j := l_pattern_count - 1
                                        l_matched := <B>False</B>
                                    <B>end</B>
                                <B>end</B>
                                j := j + 1
                            <B>end</B>
                            <B>if</B> l_matched <B>then</B>
                                <B>Result</B> := i - l_area_lower
                                i := l_end_pos
                            <B>else</B>
                                <B>if</B> i + l_pattern_count &lt;= end_pos <B>then</B>
                                    <B>from</B>
                                        j := 0
                                        l_min_offset := l_pattern_count + 1
                                    <B>until</B>
                                        j &gt; fuzzy
                                    <B>loop</B>
                                        l_char_code := l_area.<A HREF="../elks/special_flat.html#f_item">item</A> (i + l_pattern_count - j - 1).<A HREF="../elks/character_8_flat.html#f_code">code</A>
                                        l_min_offset := l_min_offset.<A HREF="../elks/comparable_flat.html#f_min">min</A> (l_deltas_array.<A HREF="../elks/special_flat.html#f_item">item</A> (j).<A HREF="../elks/special_flat.html#f_item">item</A> (l_char_code))
                                        j := j + 1
                                    <B>end</B>
                                    i := i + l_min_offset
                                <B>else</B>
                                    i := i + 1
                                <B>end</B>
                            <B>end</B>
                        <B>end</B>
                    <B>end</B>
                    <A HREF="../elks/string_searcher_flat.html#f_deltas_array">deltas_array</A> := <B>Void</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_substring_index"><A HREF="../elks/string_searcher_flat.html#f_substring_index">substring_index</A> (a_string: <B>like</B> <A HREF="../elks/string_8_searcher_flat.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of first occurrence of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> and before </FONT>`end_pos'<FONT COLOR="red"> in </FONT>`a_string'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 0 if there are no matches.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_8_flat.html#f_count">count</A>
        <B>do</B>
            <B>if</B> a_string = a_pattern <B>then</B>
                <B>if</B> start_pos = 1 <B>then</B>
                    <B>Result</B> := 1
                <B>end</B>
            <B>else</B>
                <B>if</B> a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A> = 0 <B>then</B>
                    <B>Result</B> := start_pos
                <B>elseif</B> a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A> &lt;= end_pos - start_pos + 1 <B>then</B>
                    <A HREF="../elks/string_searcher_flat.html#f_internal_initialize_deltas">internal_initialize_deltas</A> (a_pattern, a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>, <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>)
                    <B>Result</B> := <A HREF="../elks/string_8_searcher_flat.html#f_substring_index_with_deltas">substring_index_with_deltas</A> (a_string, a_pattern, start_pos, end_pos)
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_substring_index_list_with_deltas"><A HREF="../elks/string_searcher_flat.html#f_substring_index_list_with_deltas">substring_index_list_with_deltas</A> (a_string: <B>like</B> <A HREF="../elks/string_8_searcher_flat.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <B>detachable</B> <A HREF="../elks/arrayed_list_flat.html">ARRAYED_LIST</A> [<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Index positions of all occurrences of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'<FONT COLOR="red"> until </FONT>`end_pos'<FONT COLOR="red"> in </FONT>`a_string'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Result is Void if there are no matches.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_not_empty: <B>not</B> a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_is_empty">is_empty</A>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_8_flat.html#f_count">count</A>
        <B>local</B>
            l_pattern_count, l_index: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            l_index := <A HREF="../elks/string_8_searcher_flat.html#f_substring_index_with_deltas">substring_index_with_deltas</A> (a_string, a_pattern, start_pos, end_pos)
            <B>if</B> l_index &gt; 0 <B>then</B>
                <B>from</B>
                    l_pattern_count := a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list_flat.html#f_make">make</A> ((((end_pos - start_pos).<A HREF="../elks/comparable_flat.html#f_max">max</A> (3) // (l_index + l_pattern_count)) // 4).<A HREF="../elks/comparable_flat.html#f_max">max</A> (2))
                <B>until</B>
                    l_index = 0
                <B>loop</B>
                    <B>Result</B>.<A HREF="../elks/arrayed_list_flat.html#f_extend">extend</A> (l_index)
                    l_index := <A HREF="../elks/string_8_searcher_flat.html#f_substring_index_with_deltas">substring_index_with_deltas</A> (a_string, a_pattern, l_index + l_pattern_count, end_pos)
                <B>end</B>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            matches: <B>Result</B> /= <B>Void</B> <B>implies</B> <B>not</B> <B>Result</B>.<A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_substring_index_with_deltas"><A HREF="../elks/string_8_searcher_flat.html#f_substring_index_with_deltas">substring_index_with_deltas</A> (a_string: <B>like</B> <A HREF="../elks/string_8_searcher_flat.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of first occurrence of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'<FONT COLOR="red"> in </FONT>`a_string'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 0 if there are no matches.</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_not_empty: <B>not</B> a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_is_empty">is_empty</A>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_8_flat.html#f_count">count</A>
        <B>local</B>
            i, j, l_end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_pattern_count: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_matched: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            l_char_code: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            l_deltas: <B>like</B> <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>
            l_area: <A HREF="../elks/special_flat.html">SPECIAL</A> [<A HREF="../elks/character_8_flat.html">CHARACTER_8</A>]
            l_area_lower: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> a_string = a_pattern <B>then</B>
                <B>if</B> start_pos = 1 <B>then</B>
                    <B>Result</B> := 1
                <B>end</B>
            <B>else</B>
                l_pattern_count := a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
                <B>check</B>
                    l_pattern_count_positive: l_pattern_count &gt; 0
                <B>end</B>
                <B>from</B>
                    l_area := a_string.<A HREF="../elks/readable_string_8_flat.html#f_area">area</A>
                    l_area_lower := a_string.<A HREF="../elks/readable_string_8_flat.html#f_area_lower">area_lower</A>
                    i := start_pos + l_area_lower
                    l_deltas := <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>
                    l_end_pos := end_pos + 1 + l_area_lower
                <B>until</B>
                    i + l_pattern_count &gt; l_end_pos
                <B>loop</B>
                    <B>from</B>
                        j := 0
                        l_matched := <B>True</B>
                    <B>until</B>
                        j = l_pattern_count
                    <B>loop</B>
                        <B>if</B> l_area.<A HREF="../elks/special_flat.html#f_item">item</A> (i + j - 1).<A HREF="../elks/character_8_ref_flat.html#f_natural_32_code">natural_32_code</A> /= a_pattern.<A HREF="../elks/readable_string_general_flat.html#f_code">code</A> (j + 1) <B>then</B>
                            j := l_pattern_count - 1
                            l_matched := <B>False</B>
                        <B>end</B>
                        j := j + 1
                    <B>end</B>
                    <B>if</B> l_matched <B>then</B>
                        <B>Result</B> := i - l_area_lower
                        i := l_end_pos
                    <B>else</B>
                        <B>if</B> i + l_pattern_count &lt;= end_pos <B>then</B>
                            l_char_code := l_area.<A HREF="../elks/special_flat.html#f_item">item</A> (i + l_pattern_count - 1).<A HREF="../elks/character_8_flat.html#f_code">code</A>
                            i := i + l_deltas.<A HREF="../elks/special_flat.html#f_item">item</A> (l_char_code)
                        <B>else</B>
                            i := i + 1
                        <B>end</B>
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>
    
<B>invariant</B>
        <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/string_searcher_flat.html">STRING_SEARCHER</A>
    deltas_not_void: <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A> /= <B>Void</B>
    deltas_valid: <A HREF="../elks/string_searcher_flat.html#f_deltas">deltas</A>.<A HREF="../elks/special_flat.html#f_capacity">capacity</A> = <A HREF="../elks/string_8_searcher_flat.html#f_max_code_point_value">Max_code_point_value</A> + 1

        <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
    reflexive_equality: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (<B>Current</B>)
    reflexive_conformance: <A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (<B>Current</B>)

<B>note</B>
    copyright: "Copyright (c) 1984-2012, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/string_8_searcher_flat.html">STRING_8_SEARCHER</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="string_8_searcher_chart.html">Chart</A></TD><TD><A HREF="string_8_searcher_links.html">Relations</A></TD><TD><A HREF="string_8_searcher.html">Text</A></TD><TD>Flat</TD><TD><A HREF="string_8_searcher_short.html">Contracts</A></TD><TD><A HREF="string_8_searcher_flatshort.html">Flat contracts</A></TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

