<HTML><HEAD>
<meta name="description" content="TTTPlatform specific encoding of Unicode strings. By default, UTF-8 on unix or UTF-16 on Windows.  TTTMixed-encoding consideration TTT============================  TTTMost operating systems have conventions for strings that are incompatible with Unicode. TTTOn UNIX, a string is just a null-terminated byte sequence, it does not follow any TTTspecific encoding. Usually the locale setting enables you to see the string the way TTTyou expect. TTTOn Windows, the sequence of names is made of null-terminated UTF-16 code unit sequence. Windows TTTdoes not guarantee that the sequence is actually a valid UTF-16 sequence.  TTTIn other words, when there is an invalid UTF-8 encoding on UNIX, or an invalid UTF-16 encoding TTTon Windows, the string is not directly representable as a Unicode string. To make it possible TTTto create and store strings in a textually representable form, the query `string' will create TTTan encoded representation that can be then later used in `make' to create a NATIVE_STRING TTTequivalent to the original string. The encoding is described in UTF_CONVERTER's note clause TTTand is a fourth variant of the recommended practice for replacement characters in Unicode TTT(see http://www.unicode.org/review/pr-121.html). "/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2012, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>native_string Flat</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="native_string_chart.html">Chart</A></TD><TD><A HREF="native_string_links.html">Relations</A></TD><TD><A HREF="native_string.html">Text</A></TD><TD>Flat</TD><TD><A HREF="native_string_short.html">Contracts</A></TD><TD><A HREF="native_string_flatshort.html">Flat contracts</A></TD></TR></TABLE><B>note</B>
    description: "[
        			Platform specific encoding of Unicode strings. By default, UTF-8 on unix or UTF-16 on Windows.
        
        			Mixed-encoding consideration
        			============================
        
        			Most operating systems have conventions for strings that are incompatible with Unicode.
        			On UNIX, a string is just a null-terminated byte sequence, it does not follow any
        			specific encoding. Usually the locale setting enables you to see the string the way
        			you expect.
        			On Windows, the sequence of names is made of null-terminated UTF-16 code unit sequence. Windows
        			does not guarantee that the sequence is actually a valid UTF-16 sequence.
        
        			In other words, when there is an invalid UTF-8 encoding on UNIX, or an invalid UTF-16 encoding
        			on Windows, the string is not directly representable as a Unicode string. To make it possible
        			to create and store strings in a textually representable form, the query <A HREF="../elks/native_string_flat.html#f_string">string</A> will create
        			an encoded representation that can be then later used in <A HREF="../elks/native_string_flat.html#f_make">make</A> to create a NATIVE_STRING
        			equivalent to the original string. The encoding is described in UTF_CONVERTER's note clause
        			and is a fourth variant of the recommended practice for replacement characters in Unicode
        			(see <a href="http://www.unicode.org/review/pr-121.html">http://www.unicode.org/review/pr-121.html</a>).
        
    ]"
    date: "$Date: 2013-03-22 09:04:25 -0700 (Fri, 22 Mar 2013) $"
    revision: "$Revision: 92334 $"

<B>class</B> 
    <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>

<B>create</B> 
    <A HREF="../elks/native_string_flat.html#f_make">make</A>,
    <A HREF="../elks/native_string_flat.html#f_make_empty">make_empty</A>,
    <A HREF="../elks/native_string_flat.html#f_make_from_pointer">make_from_pointer</A>,
    <A HREF="../elks/native_string_flat.html#f_make_from_raw_string">make_from_raw_string</A>

<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_default_create"><A HREF="../elks/any_flat.html#f_default_create">default_create</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Process instances of classes with no creation clause.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Default: do nothing.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_make"><A HREF="../elks/native_string_flat.html#f_make">make</A> (a_string: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize an instance of Current using </FONT>`a_string'<FONT COLOR="red"> treated as a sequence</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of Unicode characters.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/native_string_flat.html#f_make_empty">make_empty</A> (a_string.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>)
            <A HREF="../elks/native_string_flat.html#f_set_string">set_string</A> (a_string)
        <B>end</B></A>

    <A NAME="f_make_empty"><A HREF="../elks/native_string_flat.html#f_make_empty">make_empty</A> (a_length: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize an empty instance of Current that will accommodate </FONT>`a_length'<FONT COLOR="red"> code units.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The memory area is not initialized.</FONT>
        <B>require</B>
            a_length_positive: a_length &gt;= 0
        <B>do</B>
            <B>create</B> <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_make">make</A> ((a_length + 1) * <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
            <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> := 0
        <B>end</B></A>

    <A NAME="f_make_from_pointer"><A HREF="../elks/native_string_flat.html#f_make_from_pointer">make_from_pointer</A> (a_pointer: <A HREF="../elks/pointer_flat.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT>`a_pointer'<FONT COLOR="red">, a platform system specific null-terminated string.</FONT>
        <B>require</B>
            a_path_pointer_not_null: a_pointer /= <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>
        <B>local</B>
            l_count: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            l_count := <A HREF="../elks/native_string_handler_flat.html#f_pointer_length_in_bytes">pointer_length_in_bytes</A> (a_pointer)
            <B>create</B> <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_make_from_pointer">make_from_pointer</A> (a_pointer, l_count + <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
            <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> := l_count // <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>
        <B>end</B></A>

    <A NAME="f_make_from_raw_string"><A HREF="../elks/native_string_flat.html#f_make_from_raw_string">make_from_raw_string</A> (a_raw_string: <B>like</B> <A HREF="../elks/native_string_flat.html#f_raw_string">raw_string</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT>`a_raw_string'<FONT COLOR="red">.</FONT>
        <B>require</B>
            a_raw_string_not_void: a_raw_string /= <B>Void</B>
        <B>local</B>
            i: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_make">make</A> (a_raw_string.<A HREF="../elks/readable_string_8_flat.html#f_count">count</A> + <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
            <B>across</B>
                a_raw_string <B>as</B> l_c
            <B>loop</B>
                <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_put_character">put_character</A> (l_c.<A HREF="../elks/indexable_iteration_cursor_flat.html#f_item">item</A>, i)
                i := i + 1
            <B>end</B>
            <B>if</B> {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>then</B>
                <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_put_natural_16">put_natural_16</A> (0.<A HREF="../elks/integer_32_ref_flat.html#f_to_natural_16">to_natural_16</A>, i)
            <B>else</B>
                <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_put_natural_8">put_natural_8</A> (0.<A HREF="../elks/integer_32_ref_flat.html#f_to_natural_8">to_natural_8</A>, i)
            <B>end</B>
            <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> := (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_count">count</A> - <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>) // <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>
        <B>ensure</B>
            set: <A HREF="../elks/native_string_flat.html#f_raw_string">raw_string</A>.<A HREF="../elks/readable_string_8_flat.html#f_same_string">same_string</A> (a_raw_string)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_generating_type"><A HREF="../elks/any_flat.html#f_generating_type">generating_type</A>: <A HREF="../elks/type_flat.html">TYPE</A> [<B>detachable</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type of current object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (type of which it is a direct instance)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := {<B>detachable</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>}
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            generating_type_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_generator"><A HREF="../elks/any_flat.html#f_generator">generator</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Name of current object's generating class</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (base class of the type of which it is a direct instance)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            generator_not_void: <B>Result</B> /= <B>Void</B>
            generator_not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/finite_flat.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_item"><A HREF="../elks/native_string_flat.html#f_item">item</A>: <A HREF="../elks/pointer_flat.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Get pointer to allocated area.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_item">item</A>
        <B>ensure</B>
            item_not_null: <B>Result</B> /= <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>
        <B>end</B></A>

    <A NAME="f_managed_data"><A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>: <A HREF="../elks/managed_pointer_flat.html">MANAGED_POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hold data of Current.</FONT>

    <A NAME="f_raw_string"><A HREF="../elks/native_string_flat.html#f_raw_string">raw_string</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Sequence of bytes representing </FONT>`Current'<FONT COLOR="red">.</FONT>
        <B>local</B>
            l_cstr: <A HREF="../elks/c_string_flat.html">C_STRING</A>
        <B>do</B>
            <B>create</B> l_cstr.<A HREF="../elks/c_string_flat.html#f_make_shared_from_pointer_and_count">make_shared_from_pointer_and_count</A> (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_item">item</A>, <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_count">count</A>)
            <B>Result</B> := l_cstr.<A HREF="../elks/c_string_flat.html#f_substring">substring</A> (1, <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_count">count</A> - <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
        <B>end</B></A>

    <A NAME="f_string"><A HREF="../elks/native_string_flat.html#f_string">string</A>: <A HREF="../elks/string_32_flat.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Representation of Current up to the first null character.</FONT>
        <B>local</B>
            u: <A HREF="../elks/utf_converter_flat.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := u.<A HREF="../elks/utf_converter_flat.html#f_utf_16_0_pointer_to_escaped_string_32">utf_16_0_pointer_to_escaped_string_32</A> (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>)
            <B>else</B>
                <B>Result</B> := u.<A HREF="../elks/utf_converter_flat.html#f_utf_8_0_pointer_to_escaped_string_32">utf_8_0_pointer_to_escaped_string_32</A> (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_substring"><A HREF="../elks/native_string_flat.html#f_substring">substring</A> (start_pos, end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>): <A HREF="../elks/string_32_flat.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Copy of substring containing all code units at indices</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> between </FONT>`start_pos'<FONT COLOR="red"> and </FONT>`end_pos'<FONT COLOR="red">.</FONT>
        <B>require</B>
            start_position_big_enough: start_pos &gt;= 1
            end_position_big_enough: start_pos &lt;= end_pos + 1
            end_position_not_too_big: end_pos &lt;= (<A HREF="../elks/native_string_flat.html#f_capacity">capacity</A> // <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
        <B>local</B>
            u: <A HREF="../elks/utf_converter_flat.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_32_flat.html#f_make">make</A> (end_pos - start_pos + 1)
            <B>if</B> {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>then</B>
                u.<A HREF="../elks/utf_converter_flat.html#f_utf_16_0_subpointer_into_escaped_string_32">utf_16_0_subpointer_into_escaped_string_32</A> (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>, start_pos - 1, end_pos - 1, <B>False</B>, <B>Result</B>)
            <B>else</B>
                <B>Result</B> := u.<A HREF="../elks/utf_converter_flat.html#f_utf_8_0_pointer_to_escaped_string_32">utf_8_0_pointer_to_escaped_string_32</A> (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>)
                u.<A HREF="../elks/utf_converter_flat.html#f_utf_8_0_subpointer_into_escaped_string_32">utf_8_0_subpointer_into_escaped_string_32</A> (<A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>, start_pos - 1, end_pos - 1, <B>False</B>, <B>Result</B>)
            <B>end</B>
        <B>ensure</B>
            susbstring_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/native_string_handler_flat.html">NATIVE_STRING_HANDLER</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_pointer_length_in_bytes"><A HREF="../elks/native_string_handler_flat.html#f_pointer_length_in_bytes">pointer_length_in_bytes</A> (a_ptr: <A HREF="../elks/pointer_flat.html">POINTER</A>): <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Length in bytes of a platform specific file name pointer, not</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> including the null-terminating character. If size is too large</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to fit into an </FONT><FONT COLOR="red">{</FONT><FONT COLOR="red">INTEGER</FONT><FONT COLOR="red">}</FONT><FONT COLOR="red"> instance, the size is truncated to</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`{INTEGER_32}.max_value'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/native_string_handler_flat.html">NATIVE_STRING_HANDLER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/native_string_handler_flat.html">NATIVE_STRING_HANDLER</A>
            a_ptr_not_null: a_ptr /= <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>
        <B>local</B>
            l_length: <A HREF="../elks/natural_64_flat.html">NATURAL_64</A>
        <B>do</B>
            l_length := <A HREF="../elks/native_string_handler_flat.html#f_c_pointer_length_in_bytes">c_pointer_length_in_bytes</A> (a_ptr)
            <B>if</B> l_length &lt;= {<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>}.<A HREF="../elks/integer_32_ref_flat.html#f_max_value">max_value</A>.<A HREF="../elks/integer_32_ref_flat.html#f_to_natural_64">to_natural_64</A> <B>then</B>
                <B>Result</B> := l_length.<A HREF="../elks/natural_64_ref_flat.html#f_to_integer_32">to_integer_32</A>
            <B>else</B>
                <B>Result</B> := {<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>}.<A HREF="../elks/integer_32_ref_flat.html#f_max_value">max_value</A>
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Measurement</FONT>

    <A NAME="f_bytes_count"><A HREF="../elks/native_string_flat.html#f_bytes_count">bytes_count</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of bytes used by Current not including the null terminating character.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> * <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>
        <B>ensure</B>
            bytes_count_non_negative: <B>Result</B> &gt;= 0
        <B>end</B></A>

    <A NAME="f_capacity"><A HREF="../elks/native_string_flat.html#f_capacity">capacity</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of bytes in Current.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_unit_count"><A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of units used by Current not including the null terminating unit.</FONT>

    <A NAME="f_unit_size"><A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Size in bytes of a unit for </FONT>`storage'<FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := 2
            <B>else</B>
                <B>Result</B> := 1
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Comparison</FONT>

    <A NAME="f_deep_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> or attached to isomorphic object structures?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            shallow_implies_deep: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (a, b) <B>implies</B> <B>Result</B>
            both_or_none_void: (a = <B>Void</B>) <B>implies</B> (<B>Result</B> = (b = <B>Void</B>))
            same_type: (<B>Result</B> <B>and</B> (a /= <B>Void</B>)) <B>implies</B> (b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_same_type">same_type</A> (b))
            symmetric: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (b, a)
        <B>end</B></A>

    <A NAME="f_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_equal">equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void or attached</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to objects considered equal?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (a = <B>Void</B> <B>and</B> b = <B>Void</B>) <B>or else</B> ((a /= <B>Void</B> <B>and</B> b /= <B>Void</B>) <B>and then</B> a.<A HREF="../elks/any_flat.html#f_is_equal">is_equal</A> (b))
        <B>end</B></A>

    <A NAME="f_is_deep_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (other: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`Current'<FONT COLOR="red"> and </FONT>`other'<FONT COLOR="red"> attached to isomorphic object structures?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            shallow_implies_deep: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other) <B>implies</B> <B>Result</B>
            same_type: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
            symmetric: <B>Result</B> <B>implies</B> other.<A HREF="../elks/any_flat.html#f_is_deep_equal">is_deep_equal</A> (<B>Current</B>)
        <B>end</B></A>

    <A NAME="f_is_equal"><A HREF="../elks/native_string_flat.html#f_is_equal">is_equal</A> (other: <B>like</B> <B>Current</B>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is content of string identical to content of string </FONT>`other'<FONT COLOR="red">?</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string_flat.html#f_item">item</A>.<A HREF="../elks/pointer_ref_flat.html#f_is_equal">is_equal</A> (other.<A HREF="../elks/native_string_flat.html#f_item">item</A>)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            symmetric: <B>Result</B> <B>implies</B> other ~ <B>Current</B>
            consistent: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other) <B>implies</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_standard_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (a: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>; b: <B>like</B> arg #1): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT>`a'<FONT COLOR="red"> and </FONT>`b'<FONT COLOR="red"> either both void or attached to</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> field-by-field identical objects of the same type?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default object comparison criterion.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> a = <B>Void</B> <B>then</B>
                <B>Result</B> := b = <B>Void</B>
            <B>else</B>
                <B>Result</B> := b /= <B>Void</B> <B>and then</B> a.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (b)
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (a = <B>Void</B> <B>and</B> b = <B>Void</B>) <B>or else</B> ((a /= <B>Void</B> <B>and</B> b /= <B>Void</B>) <B>and then</B> a.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (b))
        <B>end</B></A>

    <A NAME="f_standard_is_equal"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT>`other'<FONT COLOR="red"> attached to an object of the same type</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> as current object, and field-by-field identical to it?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            same_type: <B>Result</B> <B>implies</B> <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
            symmetric: <B>Result</B> <B>implies</B> other.<A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (<B>Current</B>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_conforms_to"><A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (other: <A HREF="../elks/any_flat.html">ANY</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does type of current object conform to type</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of </FONT>`other'<FONT COLOR="red"> (as per Eiffel: The Language, chapter 13)?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>end</B></A>

    <A NAME="f_same_type"><A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other: <A HREF="../elks/any_flat.html">ANY</A>): <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is type of current object identical to type of </FONT>`other'<FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            definition: <B>Result</B> = (<A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (other) <B>and</B> other.<A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (<B>Current</B>))
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element change</FONT>

    <A NAME="f_set_shared_from_pointer"><A HREF="../elks/native_string_flat.html#f_set_shared_from_pointer">set_shared_from_pointer</A> (a_ptr: <A HREF="../elks/pointer_flat.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New instance sharing </FONT>`a_ptr'<FONT COLOR="red">.</FONT>
        <B>require</B>
            a_ptr_not_null: a_ptr /= <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>
        <B>do</B>
            <A HREF="../elks/native_string_flat.html#f_set_shared_from_pointer_and_count">set_shared_from_pointer_and_count</A> (a_ptr, <A HREF="../elks/native_string_handler_flat.html#f_pointer_length_in_bytes">pointer_length_in_bytes</A> (a_ptr))
        <B>end</B></A>

    <A NAME="f_set_shared_from_pointer_and_count"><A HREF="../elks/native_string_flat.html#f_set_shared_from_pointer_and_count">set_shared_from_pointer_and_count</A> (a_ptr: <A HREF="../elks/pointer_flat.html">POINTER</A>; a_length: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New instance sharing </FONT>`a_ptr'<FONT COLOR="red"> of </FONT>`a_length'<FONT COLOR="red"> byte. Space for an additional</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> null terminating code unit is added to </FONT><A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_ptr_not_null: a_ptr /= <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>
            a_length_non_negative: a_length &gt;= 0
            a_length_valid: (a_length \\ <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>) = 0
        <B>do</B>
            <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> := a_length // <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>
            <B>if</B> <B>not</B> <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_is_shared">is_shared</A> <B>then</B>
                <B>create</B> <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_share_from_pointer">share_from_pointer</A> (a_ptr, a_length + <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
            <B>else</B>
                <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_set_from_pointer">set_from_pointer</A> (a_ptr, a_length + <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_set_string"><A HREF="../elks/native_string_flat.html#f_set_string">set_string</A> (a_string: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/native_string_flat.html#f_string">string</A><FONT COLOR="red"> with </FONT>`a_string'<FONT COLOR="red">	treated as a sequence of Unicode characters.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/native_string_flat.html#f_set_substring">set_substring</A> (a_string, 1, a_string.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>)
        <B>end</B></A>

    <A NAME="f_set_substring"><A HREF="../elks/native_string_flat.html#f_set_substring">set_substring</A> (a_string: <A HREF="../elks/readable_string_general_flat.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_flat.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><A HREF="../elks/native_string_flat.html#f_string">string</A><FONT COLOR="red"> with a subset of </FONT>`a_string'<FONT COLOR="red"> from </FONT>`a_start_pos'<FONT COLOR="red"> index to </FONT>`end_pos'<FONT COLOR="red"> index.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
            start_position_big_enough: start_pos &gt;= 1
            end_position_big_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_general_flat.html#f_count">count</A>
        <B>local</B>
            u: <A HREF="../elks/utf_converter_flat.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>then</B>
                u.<A HREF="../elks/utf_converter_flat.html#f_escaped_utf_32_substring_into_utf_16_0_pointer">escaped_utf_32_substring_into_utf_16_0_pointer</A> (a_string, start_pos, end_pos, <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>, 0, <A HREF="../elks/native_string_flat.html#f_upper_cell">Upper_cell</A>)
            <B>else</B>
                u.<A HREF="../elks/utf_converter_flat.html#f_escaped_utf_32_substring_into_utf_8_0_pointer">escaped_utf_32_substring_into_utf_8_0_pointer</A> (a_string, start_pos, end_pos, <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>, 0, <A HREF="../elks/native_string_flat.html#f_upper_cell">Upper_cell</A>)
            <B>end</B>
            <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> := <A HREF="../elks/native_string_flat.html#f_upper_cell">Upper_cell</A>.<A HREF="../elks/cell_flat.html#f_item">item</A> // <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_clone">clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void; otherwise new object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> equal to </FONT>`other'
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> For non-void </FONT>`other'<FONT COLOR="red">, </FONT><A HREF="../elks/any_flat.html#f_clone">clone</A><FONT COLOR="red"> calls </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to change copying/cloning semantics, redefine </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_twin">twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            equal: <B>Result</B> ~ other
        <B>end</B></A>

    <A NAME="f_copy"><A HREF="../elks/any_flat.html#f_copy">copy</A> (other: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Update current object using fields of object attached</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to </FONT>`other'<FONT COLOR="red">, so as to yield equal objects.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
            type_identity: <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            is_equal: <B>Current</B> ~ other
        <B>end</B></A>

    <A NAME="f_deep_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_clone">deep_clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `deep_twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void: otherwise, new object structure</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> recursively duplicated from the one attached to </FONT>`other'
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (other, <B>Result</B>)
        <B>end</B></A>

    <A NAME="f_deep_copy"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_copy">deep_copy</A> (other: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Effect equivalent to that of:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">		</FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red"> (</FONT>`other'<FONT COLOR="red"> . </FONT><A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A><FONT COLOR="red">)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/any_flat.html#f_copy">copy</A> (other.<A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>)
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (<B>Current</B>, other)
        <B>end</B></A>

    <A NAME="f_deep_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_deep_twin">deep_twin</A>: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object structure recursively duplicated from Current.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            deep_twin_not_void: <B>Result</B> /= <B>Void</B>
            deep_equal: <A HREF="../elks/any_flat.html#f_deep_equal">deep_equal</A> (<B>Current</B>, <B>Result</B>)
        <B>end</B></A>

    <A NAME="f_standard_clone"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_clone">standard_clone</A> (other: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>): <B>like</B> other
        <B>obsolete</B> "Use `standard_twin' instead."
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Void if </FONT>`other'<FONT COLOR="red"> is void; otherwise new object</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> field-by-field identical to </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default copying semantics.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Void</B> <B>then</B>
                <B>Result</B> := other.<A HREF="../elks/any_flat.html#f_standard_twin">standard_twin</A>
            <B>end</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            equal: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (<B>Result</B>, other)
        <B>end</B></A>

    <A NAME="f_standard_copy"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_copy">standard_copy</A> (other: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Copy every field of </FONT>`other'<FONT COLOR="red"> onto corresponding field</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            other_not_void: other /= <B>Void</B>
            type_identity: <A HREF="../elks/any_flat.html#f_same_type">same_type</A> (other)
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            is_standard_equal: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (other)
        <B>end</B></A>

    <A NAME="f_standard_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_standard_twin">standard_twin</A>: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object field-by-field identical to </FONT>`other'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Always uses default copying semantics.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            standard_twin_not_void: <B>Result</B> /= <B>Void</B>
            equal: <A HREF="../elks/any_flat.html#f_standard_equal">standard_equal</A> (<B>Result</B>, <B>Current</B>)
        <B>end</B></A>

    <A NAME="f_twin"><B>frozen</B> <A HREF="../elks/any_flat.html#f_twin">twin</A>: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New object equal to </FONT>`Current'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><A HREF="../elks/any_flat.html#f_twin">twin</A><FONT COLOR="red"> calls </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">; to change copying/twinning semantics, redefine </FONT><A HREF="../elks/any_flat.html#f_copy">copy</A><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            twin_not_void: <B>Result</B> /= <B>Void</B>
            is_equal: <B>Result</B> ~ <B>Current</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Basic operations</FONT>

    <A NAME="f_as_attached"><B>frozen</B> <A HREF="../elks/any_flat.html#f_as_attached">as_attached</A>: <B>attached</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Attached version of Current</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Can be used during transitional period to convert</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> non-void-safe classes to void-safe ones.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <B>Current</B>
        <B>end</B></A>

    <A NAME="f_default"><B>frozen</B> <A HREF="../elks/any_flat.html#f_default">default</A>: <B>detachable</B> <A HREF="../elks/native_string_flat.html">NATIVE_STRING</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of object's type</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_default_pointer"><B>frozen</B> <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>: <A HREF="../elks/pointer_flat.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of type </FONT>`POINTER'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Avoid the need to write </FONT>`p'<FONT COLOR="red">.</FONT><A HREF="../elks/any_flat.html#f_default">default</A><FONT COLOR="red"> for</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> some </FONT>`p'<FONT COLOR="red"> of type </FONT>`POINTER'<FONT COLOR="red">.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_default_rescue"><A HREF="../elks/any_flat.html#f_default_rescue">default_rescue</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Process exception for routines with no Rescue clause.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Default: do nothing.)</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_do_nothing"><B>frozen</B> <A HREF="../elks/any_flat.html#f_do_nothing">do_nothing</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Execute a null action.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_c_pointer_length_in_bytes"><A HREF="../elks/native_string_handler_flat.html#f_c_pointer_length_in_bytes">c_pointer_length_in_bytes</A> (a_ptr: <A HREF="../elks/pointer_flat.html">POINTER</A>): <A HREF="../elks/natural_64_flat.html">NATURAL_64</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Length in bytes of a platform specific file name pointer, not</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> including the null-terminating character.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/native_string_handler_flat.html">NATIVE_STRING_HANDLER</A><FONT COLOR="red">)</FONT>
        <B>require</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/native_string_handler_flat.html">NATIVE_STRING_HANDLER</A>
            a_ptr_not_null: a_ptr /= <A HREF="../elks/any_flat.html#f_default_pointer">default_pointer</A>
        <B>external</B>
            "C inline use %"eif_eiffel.h%""
        <B>alias</B>
            "{
			#ifdef EIF_WINDOWS
				return (EIF_NATURAL_64) wcslen($a_ptr) * sizeof(wchar_t);
			#else
				return (EIF_NATURAL_64) strlen($a_ptr) * sizeof(char);
			#endif
            }"
        <B>end</B></A>

    <A NAME="f_platform"><A HREF="../elks/native_string_flat.html#f_platform">Platform</A>: <A HREF="../elks/platform_flat.html">PLATFORM</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access underlying platform info, used to satisfy invariant below.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_upper_cell"><A HREF="../elks/native_string_flat.html#f_upper_cell">Upper_cell</A>: <A HREF="../elks/cell_flat.html">CELL</A> [<A HREF="../elks/integer_32_flat.html">INTEGER_32</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Temporary storage for byte index of last insertions when using UTF_CONVERTER routines.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/cell_flat.html#f_put">put</A> (0)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Output</FONT>

    <A NAME="f_io"><A HREF="../elks/any_flat.html#f_io">Io</A>: <A HREF="../elks/std_files_flat.html">STD_FILES</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Handle to standard file setup</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
            <B>Result</B>.<A HREF="../elks/std_files_flat.html#f_set_output_default">set_output_default</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            io_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_out"><A HREF="../elks/any_flat.html#f_out">out</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New string containing terse printable representation</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/any_flat.html#f_tagged_out">tagged_out</A>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            out_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_print"><A HREF="../elks/any_flat.html#f_print">print</A> (o: <B>detachable</B> <A HREF="../elks/any_flat.html">ANY</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Write terse external representation of </FONT>`o'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> on standard output.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>do</B>
            <B>if</B> o /= <B>Void</B> <B>then</B>
                <A HREF="../elks/any_flat.html#f_io">Io</A>.<A HREF="../elks/std_files_flat.html#f_put_string">put_string</A> (o.<A HREF="../elks/any_flat.html#f_out">out</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_tagged_out"><B>frozen</B> <A HREF="../elks/any_flat.html#f_tagged_out">tagged_out</A>: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New string containing terse printable representation</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of current object</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>external</B>
            "built_in"
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            tagged_out_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Platform</FONT>

    <A NAME="f_operating_environment"><A HREF="../elks/any_flat.html#f_operating_environment">Operating_environment</A>: <A HREF="../elks/operating_environment_flat.html">OPERATING_ENVIRONMENT</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Objects available from the operating system</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>ensure</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
            operating_environment_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Retrieval</FONT>

    <A NAME="f_internal_correct_mismatch"><B>frozen</B> <A HREF="../elks/any_flat.html#f_internal_correct_mismatch">internal_correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Called from runtime to perform a proper dynamic dispatch on </FONT>`correct_mismatch'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> from MISMATCH_CORRECTOR.</FONT>
            <FONT COLOR="red">--</FONT> <FONT COLOR="red">(from </FONT><A HREF="../elks/any_flat.html">ANY</A><FONT COLOR="red">)</FONT>
        <B>local</B>
            l_msg: <A HREF="../elks/string_8_flat.html">STRING_8</A>
            l_exc: <A HREF="../elks/exceptions_flat.html">EXCEPTIONS</A>
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/mismatch_corrector_flat.html">MISMATCH_CORRECTOR</A>} <B>Current</B> <B>as</B> l_corrector <B>then</B>
                l_corrector.<A HREF="../elks/mismatch_corrector_flat.html#f_correct_mismatch">correct_mismatch</A>
            <B>else</B>
                <B>create</B> l_msg.<A HREF="../elks/readable_string_8_flat.html#f_make_from_string">make_from_string</A> ("Mismatch: ")
                <B>create</B> l_exc
                l_msg.<A HREF="../elks/string_8_flat.html#f_append">append</A> (<A HREF="../elks/any_flat.html#f_generating_type">generating_type</A>.<A HREF="../elks/type_flat.html#f_name">name</A>)
                l_exc.<A HREF="../elks/exceptions_flat.html#f_raise_retrieval_exception">raise_retrieval_exception</A> (l_msg)
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status Report</FONT>

    <A NAME="f_is_empty"><A HREF="../elks/native_string_flat.html#f_is_empty">is_empty</A>: <A HREF="../elks/boolean_flat.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current empty?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string_flat.html#f_unit_count">unit_count</A> = 0
        <B>end</B></A>
    
<B>invariant</B>
    little_endian_windows: {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>implies</B> <A HREF="../elks/native_string_flat.html#f_platform">Platform</A>.<A HREF="../elks/platform_flat.html#f_is_little_endian">Is_little_endian</A>
    even_count_on_windows: {<A HREF="../elks/platform_flat.html">PLATFORM</A>}.<A HREF="../elks/platform_flat.html#f_is_windows">is_windows</A> <B>implies</B> <A HREF="../elks/native_string_flat.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer_flat.html#f_count">count</A> \\ <A HREF="../elks/native_string_flat.html#f_unit_size">unit_size</A> = 0

        <FONT COLOR="red">--</FONT> <FONT COLOR="red">from </FONT><A HREF="../elks/any_flat.html">ANY</A>
    reflexive_equality: <A HREF="../elks/any_flat.html#f_standard_is_equal">standard_is_equal</A> (<B>Current</B>)
    reflexive_conformance: <A HREF="../elks/any_flat.html#f_conforms_to">conforms_to</A> (<B>Current</B>)

<B>note</B>
    copyright: "Copyright (c) 1984-2012, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/native_string_flat.html">NATIVE_STRING</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="native_string_chart.html">Chart</A></TD><TD><A HREF="native_string_links.html">Relations</A></TD><TD><A HREF="native_string.html">Text</A></TD><TD>Flat</TD><TD><A HREF="native_string_short.html">Contracts</A></TD><TD><A HREF="native_string_flatshort.html">Flat contracts</A></TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

