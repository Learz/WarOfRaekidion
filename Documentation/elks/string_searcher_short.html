<HTML><HEAD>
<meta name="description" content="Helper to perform efficient search of a string in another one. Note: The algorithm used is the one described in Communications of the ACM, Tvolume 33, number 8, August 1990, by Daniel M. Sunday. The fuzzy Tversion was presented by Peter R. Sibbald in Communications of the TACM, volume 35, number 4, April 1992 (Technical Correspondance)."/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="legal" content="See notice at end of class."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2012, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>string_searcher Contracts</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="string_searcher_chart.html">Chart</A></TD><TD><A HREF="string_searcher_links.html">Relations</A></TD><TD><A HREF="string_searcher.html">Text</A></TD><TD><A HREF="string_searcher_flat.html">Flat</A></TD><TD>Contracts</TD><TD><A HREF="string_searcher_flatshort.html">Flat contracts</A></TD></TR></TABLE><B>note</B>
    description: "[
        Helper to perform efficient search of a string in another one.
        Note: The algorithm used is the one described in Communications of the ACM,
        	volume 33, number 8, August 1990, by Daniel M. Sunday. The fuzzy
        	version was presented by Peter R. Sibbald in Communications of the
        	ACM, volume 35, number 4, April 1992 (Technical Correspondance).
    ]"
    library: "Free implementation of ELKS library"
    status: "See notice at end of class."
    legal: "See notice at end of class."
    date: "$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $"
    revision: "$Revision: 91981 $"

<B>deferred</B> <B>class</B> <B>interface</B>
    <A HREF="../elks/string_searcher_short.html">STRING_SEARCHER</A>

<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_initialize_deltas"><A HREF="../elks/string_searcher_short.html#f_initialize_deltas">initialize_deltas</A> (a_pattern: <A HREF="../elks/readable_string_general_short.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize </FONT><A HREF="../elks/string_searcher_short.html#f_deltas">deltas</A><FONT COLOR="red"> with </FONT>`a_pattern'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Optimized for the top </FONT><A HREF="../elks/string_searcher_short.html#f_max_code_point_value">max_code_point_value</A><FONT COLOR="red"> characters only.</FONT>
        <B>require</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
</A>    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_string_type"><A HREF="../elks/string_searcher_short.html#f_string_type">string_type</A>: <A HREF="../elks/readable_string_general_short.html">READABLE_STRING_GENERAL</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type of strings </FONT>`Current'<FONT COLOR="red"> manipulate to perform searches.</FONT>
        <B>ensure</B>
            for_typing_only: <B>False</B>
</A>
    <A NAME="f_max_code_point_value"><A HREF="../elks/string_searcher_short.html#f_max_code_point_value">max_code_point_value</A>: <A HREF="../elks/integer_32_short.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Maximum character value for which we optimize the lookup of a pattern.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If any item's code of the searched string is above that limit, search will</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> not be as efficient.</FONT>
        <B>ensure</B>
            positive: <B>Result</B> &gt; 0
</A>    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Search</FONT>

    <A NAME="f_substring_index"><A HREF="../elks/string_searcher_short.html#f_substring_index">substring_index</A> (a_string: <B>like</B> <A HREF="../elks/string_searcher_short.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_short.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_short.html">INTEGER_32</A>): <A HREF="../elks/integer_32_short.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of first occurrence of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> and before </FONT>`end_pos'<FONT COLOR="red"> in </FONT>`a_string'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 0 if there are no matches.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_general_short.html#f_count">count</A>
</A>
    <A NAME="f_substring_index_with_deltas"><A HREF="../elks/string_searcher_short.html#f_substring_index_with_deltas">substring_index_with_deltas</A> (a_string: <B>like</B> <A HREF="../elks/string_searcher_short.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_short.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_short.html">INTEGER_32</A>): <A HREF="../elks/integer_32_short.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of first occurrence of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'<FONT COLOR="red"> in </FONT>`a_string'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 0 if there are no matches.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_not_empty: <B>not</B> a_pattern.<A HREF="../elks/readable_string_general_short.html#f_is_empty">is_empty</A>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_general_short.html#f_count">count</A>
</A>
    <A NAME="f_substring_index_list_with_deltas"><A HREF="../elks/string_searcher_short.html#f_substring_index_list_with_deltas">substring_index_list_with_deltas</A> (a_string: <B>like</B> <A HREF="../elks/string_searcher_short.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_short.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32_short.html">INTEGER_32</A>): <B>detachable</B> <A HREF="../elks/arrayed_list_short.html">ARRAYED_LIST</A> [<A HREF="../elks/integer_32_short.html">INTEGER_32</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Index positions of all occurrences of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'<FONT COLOR="red"> until </FONT>`end_pos'<FONT COLOR="red"> in </FONT>`a_string'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Result is Void if there are no matches.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_not_empty: <B>not</B> a_pattern.<A HREF="../elks/readable_string_general_short.html#f_is_empty">is_empty</A>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_general_short.html#f_count">count</A>
        <B>ensure</B>
            matches: <B>Result</B> /= <B>Void</B> <B>implies</B> <B>not</B> <B>Result</B>.<A HREF="../elks/finite_short.html#f_is_empty">is_empty</A>
</A>
    <A NAME="f_fuzzy_index"><A HREF="../elks/string_searcher_short.html#f_fuzzy_index">fuzzy_index</A> (a_string: <B>like</B> <A HREF="../elks/string_searcher_short.html#f_string_type">string_type</A>; a_pattern: <A HREF="../elks/readable_string_general_short.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos, fuzzy: <A HREF="../elks/integer_32_short.html">INTEGER_32</A>): <A HREF="../elks/integer_32_short.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of first occurrence of </FONT>`a_pattern'<FONT COLOR="red"> at or after </FONT>`start_pos'<FONT COLOR="red"> in</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT>`a_string'<FONT COLOR="red"> with 0..</FONT>`fuzzy'<FONT COLOR="red"> mismatches between </FONT>`a_string'<FONT COLOR="red"> and </FONT>`a_pattern'<FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 0 if there are no fuzzy matches.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
            a_pattern_not_void: a_pattern /= <B>Void</B>
            a_pattern_not_empty: <B>not</B> a_pattern.<A HREF="../elks/readable_string_general_short.html#f_is_empty">is_empty</A>
            start_large_enough: start_pos &gt;= 1
            end_pos_large_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_general_short.html#f_count">count</A>
            fuzzy_non_negative: fuzzy &gt;= 0
            acceptable_fuzzy: fuzzy &lt;= a_pattern.<A HREF="../elks/readable_string_general_short.html#f_count">count</A>
</A>    
<B>invariant</B>
    deltas_not_void: <A HREF="../elks/string_searcher_short.html#f_deltas">deltas</A> /= <B>Void</B>
    deltas_valid: <A HREF="../elks/string_searcher_short.html#f_deltas">deltas</A>.<A HREF="../elks/special_short.html#f_capacity">capacity</A> = <A HREF="../elks/string_searcher_short.html#f_max_code_point_value">max_code_point_value</A> + 1

<B>note</B>
    copyright: "Copyright (c) 1984-2012, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/string_searcher_short.html">STRING_SEARCHER</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="string_searcher_chart.html">Chart</A></TD><TD><A HREF="string_searcher_links.html">Relations</A></TD><TD><A HREF="string_searcher.html">Text</A></TD><TD><A HREF="string_searcher_flat.html">Flat</A></TD><TD>Contracts</TD><TD><A HREF="string_searcher_flatshort.html">Flat contracts</A></TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

